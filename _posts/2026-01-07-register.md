---
layout: post
title: "[Computer Structure] Register"
date: 2026-01-07 10:26 +0900
math: true
categories:
- Computer Science
- Operating System & Computer Structure
tags:
- Computer Structure
- Register
image:
    path: /assets/img/2026-01-10-17-16-25.png
---

## 🧩 Memory Hierarchy

현대 컴퓨팅 아키텍처에서 성능의 병목은 더 이상 연산 속도 그 자체가 아닙니다. 문제는 '데이터의 이동'입니다. 프로세서가 아무리 강력한 ALU(Arithmetic Logic Unit)를 보유하고 있더라도, 연산에 필요한 피연산자를 적시에 공급받지 못하면 CPU는 그저 무의미한 클록 사이클을 소모하며 대기할 뿐입니다. 레지스터는 이 잔혹한 '지연 시간(Latency)'의 전장에서 최전방을 사수하는 고립된 요새와 같습니다.

### 물리적 거리와 지연

우리가 다루는 나노초(ns) 단위의 세계에서 '빛의 속도'는 매우 느린 물리적 제약입니다. 3GHz로 작동하는 CPU의 한 클록 사이클은 약 0.33나노초이며, 이 짧은 시간 동안 빛이 이동할 수 있는 거리는 고작 10cm 남짓입니다. 만약 데이터가 CPU 다이(Die) 외부에 있는 메인 메모리(RAM)에서 출발한다면, 전기 신호가 버스를 타고 물리적 거리를 이동하고 메모리 컨트롤러의 중재를 거쳐 돌아오는 데 수백 클록 사이클이 소모됩니다.

이러한 물리적 괴리를 극복하기 위해 하드웨어 엔지니어들은 데이터 근접성을 기준으로 계층 구조를 설계했습니다. 레지스터는 연산 장치와 물리적으로 가장 가까운 곳에 위치하며, 사실상 전선(Wire)의 연장선상에서 데이터를 즉각적으로 공급합니다. '요리사의 도마' 비유를 들자면, Disk는 먼 식재료 창고이고 RAM은 주방 옆 냉장고이지만, 레지스터는 요리사가 칼질을 하는 도마 바로 위입니다. 도마 위가 좁을수록 한 번에 다룰 수 있는 재료는 적어지지만, 손을 뻗는 거리(Latency)는 0에 수렴하게 됩니다.

### 아키텍처 상태 보존의 정점

레지스터는 단순히 빠른 저장소가 아니라, 실행 중인 프로그램의 '현재 상태(Architectural State)' 그 자체를 정의하는 결정적 공간입니다. 운영체제가 프로세스를 전환할 때(Context Switch), 가장 먼저 보호하고 복구해야 하는 핵심 데이터는 메모리 전체가 아니라 레지스터의 값들입니다. 프로그램 카운터(PC)가 가리키는 다음 명령어의 주소, 현재 수행 중인 연산의 중간 결과물, 함수 호출을 위한 스택 포인터 등이 모두 이 좁은 공간에 응축되어 있습니다.

만약 레지스터가 존재하지 않고 모든 연산이 메모리에서 직접 이루어진다면, CPU는 상태를 확인하기 위해 매번 수천 킬로미터 밖의 장부(RAM)를 확인해야 하는 비효율에 빠질 것입니다. 따라서 메모리 계층 구조의 정점에 있는 레지스터는 경제적 논리(용량 대비 가격)를 넘어선 물리적 필연성입니다. 다이 면적의 막대한 비용을 지불하면서도 수 킬로바이트(KB)조차 채우지 못하는 이 극소량의 자원이 시스템 전체의 처리량(Throughput)을 결정짓는 핵심 변수가 됩니다.

> **아키텍처적 상태와 실제 하드웨어의 분리**
> 
> 소프트웨어(컴파일러)가 인식하는 '논리적 레지스터'의 개수와 실제 실리콘에 박혀 있는 '물리적 레지스터'의 개수는 현대 아키텍처에서 일치하지 않습니다. 이는 뒤에서 다룰 레지스터 리네이밍(Register Renaming)의 토대가 됩니다.
{: .prompt-info }

## 🧩 Register

레지스터는 추상적인 데이터 저장 공간이 아닙니다. 그것은 수억 개의 트랜지스터가 정교하게 얽혀 만들어낸 논리 게이트의 물리적 결정체입니다. 메모리가 '공간'의 개념이라면, 레지스터는 '상태' 그 자체입니다. CPU 내부에서 전압의 높고 낮음(High/Low)이 어떻게 영속적인 비트 정보로 고착되는지, 그리고 수십 개의 명령어가 어떻게 충돌 없이 이 자원을 공유하는지 그 마이크로아키텍처를 파헤쳐 봅니다.

### 플립플롭의 상태 유지

디지털 회로에서 단 1비트의 정보를 '기억'하기 위해 사용하는 최소 단위는 플립플롭(Flip-Flop)입니다. 그중에서도 레지스터의 근간이 되는 D-플립플롭은 매우 흥미로운 구조를 가집니다. 두 개의 논리 게이트가 서로의 출력을 상대방의 입력으로 밀어넣는 '피드백 루프(Feedback Loop)'를 형성하고 있기 때문입니다. 

입력 신호가 끊기더라도 회로 내부에서 신호가 꼬리에 꼬리를 물고 회전하며 현재의 전압 상태를 유지합니다. 이것이 바로 하드웨어가 기억을 유지하는 본질적인 방식입니다. 클록(Clock) 신호가 상승하는 그 찰나의 순간에만 입력값이 이 루프 안으로 침투할 수 있으며, 일단 침투한 데이터는 다음 클록이 올 때까지 철저히 격리되어 보존됩니다. 이러한 래칭(Latching) 메커니즘 덕분에 CPU는 연산 중 발생하는 수많은 노이즈 속에서도 흔들리지 않는 데이터의 기준점을 확보할 수 있습니다.

![](/assets/img/2026-01-13-15-34-59.png)

### 멀티 포트 데이터 뱅크

현대 CPU는 한 번에 하나의 명령만 수행하지 않습니다. 수퍼스칼라(Superscalar) 아키텍처에서는 한 사이클에 4개 이상의 명령어가 동시에 실행되기도 합니다. 만약 레지스터가 단순한 1:1 통로만 가지고 있다면, 여러 명령어가 동시에 "EAX 레지스터 값을 읽어라"라고 요청할 때 심각한 병목이 발생할 것입니다.

이를 해결하기 위해 레지스터는 '레지스터 파일(Register File)'이라는 특수한 뱅크 구조로 설계됩니다. 일반적인 SRAM 메모리와 달리 레지스터 파일은 **멀티 포트(Multi-port)** 구조를 가집니다. 예를 들어, 2개의 쓰기 포트와 4개의 읽기 포트를 가진 레지스터 파일은 한 사이클에 4개의 명령어가 데이터를 읽어가고, 동시에 2개의 연산 결과가 기록되는 것을 허용합니다.

하지만 이 병렬성은 공짜가 아닙니다. 포트 수가 늘어날수록 각 비트 셀(Cell)을 가로지르는 워드라인과 비트라인의 수가 기하급수적으로 증가하며, 이는 다이(Die) 면적의 제곱($N^2$)에 비례하는 비용 상승을 초래합니다. 레지스터의 개수가 32개나 16개 수준에서 정체되어 있는 이유는 소프트웨어의 한계가 아니라, 배선(Wiring)의 복잡도가 실리콘 면적과 전력 소모를 감당할 수 없는 수준으로 치솟기 때문입니다.

### 시스템 제어 레지스터

모든 레지스터가 계산을 위한 식재료(Operand)를 담는 것은 아닙니다. 어떤 레지스터들은 CPU의 신경계를 통제하는 조종간 역할을 수행합니다. 우리는 이를 특수 목적 레지스터(Special Purpose Register)라 부릅니다.

* **프로그램 카운터(PC / RIP):** 다음에 실행할 명령어의 메모리 주소를 가리킵니다. 이 레지스터의 값이 변하는 순간 프로그램의 흐름(분기, 점프)이 결정됩니다.
* **스택 포인터(SP / RSP):** 현재 함수가 사용하는 메모리 구역인 '스택'의 꼭대기를 가리킵니다. 함수 호출과 반환의 질서를 유지하는 핵심 지표입니다.
* **플래그 레지스터(FLAGS / EFLAGS):** 바로 직전 연산의 결과가 0이었는지(Zero Flag), 음수였는지(Sign Flag), 혹은 오버플로가 발생했는지 등의 '상태'를 기록합니다. 이 1비트의 깃발들이 모여 조건문(`if`)의 분기를 완성합니다.

> **레지스터 파일의 하드웨어 트레이드오프**
> 
> 포트가 많을수록 성능은 올라가지만, 물리적인 배선 면적(Area)이 넓어지면서 전기적 신호가 이동해야 하는 거리가 길어집니다. 이는 역설적으로 최대 클록 주파수를 낮추는 결과를 초래할 수 있습니다. 엔지니어들은 항상 '병렬성'과 '속도' 사이의 팽팽한 줄타기를 수행합니다.
{: .prompt-warning }

## 🧩 Instruction Set Architecture

소프트웨어 엔지니어에게 레지스터는 하드웨어의 복잡한 물리적 구현을 가려주는 견고한 추상화 계층(Abstraction Layer)입니다. 프로그래밍 언어가 메모리를 '무한한 캔버스'로 묘사한다면, ISA(Instruction Set Architecture)는 레지스터를 '엄격하게 제한된 고정석'으로 정의합니다. 이 절에서는 컴파일러와 하드웨어가 이 한정된 자원을 배분하기 위해 벌이는 고도의 최적화 전략을 다룹니다.

### 자원 추상화 계층

ISA는 프로세서가 이해할 수 있는 명령어의 집합체인 동시에, 소프트웨어가 하드웨어 자원을 어떻게 사용해야 하는지에 대한 규약입니다. x86-64 아키텍처는 프로그래머에게 16개의 범용 레지스터(RAX, RBX 등)를 노출하며, ARMv8은 31개의 레지스터를 제공합니다. 

이 개수는 단순히 임의로 정해진 것이 아닙니다. 명령어 코드 내에서 레지스터 번호를 지정하는 데 필요한 비트 수(예: 32개 레지스터를 식별하려면 5비트가 필요)와 명령어 전체 길이 사이의 트레이드오프를 계산한 결과입니다. 소프트웨어는 이 '논리적 레지스터'의 개수를 하드웨어가 제공하는 절대적인 물리 자원으로 인식하고 코드를 생성합니다. 따라서 ISA는 하드웨어 설계자에게는 구현해야 할 스펙이 되고, 컴파일러 제작자에게는 지켜야 할 자원의 한계선이 됩니다.

### 레지스터 할당 전략

컴파일러의 가장 중요한 임무 중 하나는 변수를 어떤 레지스터에 배치할지 결정하는 '레지스터 할당(Register Allocation)'입니다. 변수의 수는 수천 개일 수 있지만 레지스터는 수십 개뿐이므로, 컴파일러는 각 변수의 수명 주기(Liveness)를 분석하여 서로 겹치지 않는 변수들을 같은 레지스터에 돌려막기 합니다. 이는 전산학에서 '그래프 채색 문제(Graph Coloring Problem)'로 치환되는 NP-완전 문제입니다.

최적의 할당에 실패하여 가용 레지스터가 바닥나면 컴파일러는 '레지스터 스필링(Register Spilling)'을 선택합니다. 이는 가장 덜 쓰이는 변수를 잠시 메모리(Stack)로 쫓아내고, 필요할 때마다 다시 불러오는 방식입니다. 단 한 번의 스필링만으로도 나노초 단위의 연산이 수십 나노초의 메모리 지연으로 돌변하며, 전체 프로그램의 성능 곡선을 무너뜨리는 치명적인 하락을 초래합니다.

```text
; C 코드 예시: 많은 지역 변수 사용
; int calculate(int a, int b, int c, int d, int e, int f) {
;     int x = a + b;
;     int y = c + d;
;     int z = e + f;
;     return x * y * z;
; }

; 컴파일된 어셈블리 (x86-64, 최적화 포함)
; 레지스터가 부족하여 스택(메모리)에 데이터를 임시 저장(spilling)하는 모습
calculate:
    push   rbp          ; 스택 프레임 보존
    mov    rbp, rsp
    sub    rsp, 16      ; 스택 공간 확보 (Spilling 영역)

    mov    eax, edi     ; a (edi)를 eax로 이동
    add    eax, esi     ; eax = a + b (x 계산)
    mov    DWORD PTR [rbp-4], eax ; 계산된 x를 스택에 저장 (Spilling!)

    mov    eax, edx     ; c (edx)를 eax로 이동
    add    eax, ecx     ; eax = c + d (y 계산)
    mov    DWORD PTR [rbp-8], eax ; 계산된 y를 스택에 저장 (Spilling!)

    mov    eax, r8d     ; e (r8d)를 eax로 이동
    add    eax, r9d     ; eax = e + f (z 계산)

    imul   eax, DWORD PTR [rbp-4] ; eax = z * x (스택에서 x를 다시 읽어옴)
    imul   eax, DWORD PTR [rbp-8] ; eax = (z * x) * y (스택에서 y를 다시 읽어옴)

    leave               ; 스택 프레임 복구
    ret                 ; 반환
```

> **레지스터 개수와 에너지 효율의 상관관계**
> 
> 레지스터가 많을수록 스필링이 줄어들어 성능은 향상되지만, 명령어의 길이가 길어지고 디코딩 회로가 복잡해지며 전력 소모가 증가합니다. 현대의 모바일 아키텍처(ARM)가 비교적 많은 레지스터를 가지면서도 효율을 내는 비결은 고정된 명령어 길이와 정교한 컴파일러 기술의 결합에 있습니다.
{: .prompt-tip }

## 🧩 CPU Pipeline

명령어가 한 번에 하나씩 처음부터 끝까지 실행되는 모델은 현대 아키텍처에서 더 이상 존재하지 않습니다. CPU는 공장의 컨베이어 벨트처럼 명령어를 여러 단계로 쪼개어 동시에 처리하며, 이 복잡한 흐름을 지탱하는 뼈대가 바로 레지스터입니다. 파이프라인의 각 단계 사이에서 데이터를 잠시 멈춰 세우고, 충돌이 발생할 때 데이터를 가로채는 '스테이징'과 '바이패스'의 미학을 분석합니다.

### 스테이징과 데이터 격리

파이프라인 아키텍처에서 데이터는 한 클록(Clock)마다 다음 단계로 전진합니다. 이때 각 단계(Fetch, Decode, Execute 등) 사이에는 물리적인 벽이 필요한데, 이를 **파이프라인 레지스터(Pipeline Register)** 또는 스테이징 레지스터라고 부릅니다. 

이 레지스터들의 임무는 명확합니다. 앞 단계의 연산 결과가 다음 단계로 넘어가기 전까지 그 값을 안전하게 '캡처'하여 보존하는 것입니다. 만약 이 격리 벽이 없다면, 전압의 변화가 파이프라인 전체에 순식간에 퍼져나가 서로 다른 명령어의 데이터가 뒤섞이는 대혼란이 발생할 것입니다. 레지스터는 파이프라인의 각 마디에서 데이터의 흐름을 통제하며, CPU가 고속 클록에서도 논리적 정밀함을 유지하게 만드는 핵심 장치입니다.

### 해저드와 바이패스 로직

파이프라인의 최대 위협은 데이터 의존성에서 비롯되는 **데이터 해저드(Data Hazard)**입니다. 앞선 명령어의 결과값이 아직 레지스터 파일에 기록(Writeback)되지 않았는데, 바로 다음 명령어가 그 값을 읽으려 할 때 발생합니다. 이를 단순히 기다린다면 파이프라인은 멈춰 서고(Stall), CPU의 처리량은 급감합니다.

현대 아키텍처는 이를 해결하기 위해 **포워딩(Forwarding)** 또는 **바이패스(Bypass)**라고 불리는 지름길 회로를 구축합니다. 연산 장치(ALU)의 출력부에서 나온 결과값을 레지스터 파일로 보내는 동시에, 즉시 다음 명령어의 입력부로 직접 쏘아주는 방식입니다. 데이터가 공식적인 '기록' 절차를 거치기 전에 실질적인 '사용' 장소로 먼저 점프하는 것입니다. 이 정교한 우회로는 레지스터 파일에 데이터가 안착하기까지 걸리는 수 사이클의 지연을 0으로 만듭니다.

```text
; 데이터 해저드 발생 예시
; 명령어 1: EAX 레지스터에 값을 쓴다. (Write)
add eax, ebx  ; EAX = EAX + EBX

; 명령어 2: 바로 다음 사이클에 EAX 값을 읽으려 한다. (Read)
; 만약 바이패스가 없다면, 명령어 1이 WB(Writeback) 단계까지 마칠 때까지 기다려야 한다.
mov ecx, eax  ; ECX = EAX (RAW Hazard 발생!)
```

![](/assets/img/2026-01-13-15-35-18.png)

> **파이프라인의 깊이와 레지스터 비용**
> 
> 파이프라인을 더 잘게 쪼개면(Deep Pipeline) 클록 속도를 높일 수 있지만, 그만큼 더 많은 스테이징 레지스터와 복잡한 포워딩 로직이 필요합니다. 이는 다이 면적 증가와 전력 소모의 상승으로 이어지며, 분기 예측 실패 시 비워야 할 파이프라인의 비용(Penalty)을 기하급수적으로 키우는 트레이드오프를 발생시킵니다.
{: .prompt-warning }

## Register Renaming

현대 프로세서의 성능을 이해하는 가장 핵심적인 키워드는 '가상화'입니다. 소프트웨어(ISA)가 바라보는 레지스터는 고작 수십 개에 불과하지만, 실제 실리콘 다이 위에는 수백 개의 물리적 레지스터가 존재합니다. 하드웨어는 이 간극을 메우기 위해 런타임에 레지스터의 이름을 바꾸는 '레지스터 리네이밍(Register Renaming)' 기술을 사용합니다. 이를 통해 명령어 간의 가짜 의존성을 제거하고 비순차 실행(Out-of-Order Execution)의 잠재력을 극한으로 끌어올립니다.

### 가짜 의존성 제거

프로그램 코드 내에서는 동일한 레지스터 이름을 반복해서 사용하게 됩니다. 이 과정에서 **WAR(Write-After-Read)**나 **WAW(Write-After-Write)**와 같은 데이터 의존성이 발생합니다. 이는 실제 데이터의 흐름 때문이 아니라, 단순히 '이름(레지스터 번호)'이 부족해서 발생하는 가짜 의존성(Name Dependency)입니다.

예를 들어, 첫 번째 명령어가 `RAX`를 읽고 있고 두 번째 명령어가 `RAX`에 새로운 값을 쓰려 할 때, 두 번째 명령어는 앞선 명령어가 읽기를 마칠 때까지 기다려야 합니다. 리네이밍 기술은 두 번째 명령어의 `RAX`를 내부적으로 다른 물리 레지스터(예: `P42`)로 매핑하여 이 대기 시간을 없앱니다. 덕분에 논리적으로는 충돌하는 것처럼 보이는 두 명령어가 실제로는 서로 다른 물리적 공간을 사용하며 동시에 실행될 수 있게 됩니다.

### 물리적 가상화 매핑

리네이밍의 핵심 기구는 **레지스터 별칭 테이블(RAT, Register Alias Table)**입니다. CPU가 명령어를 디코딩할 때, 명령어에 명시된 논리 레지스터 번호를 현재 가용한 물리 레지스터 풀(PRP, Physical Register Pool)의 빈 번호로 즉석에서 치환합니다. 

이 매핑 정보는 RAT에 기록되며, 이후의 명령어들은 이 테이블을 참조하여 정확한 데이터를 찾아갑니다. 결과적으로 ISA에 정의된 레지스터 세트는 일종의 '핸들' 역할을 할 뿐이며, 실제 데이터가 머무는 곳은 하드웨어가 동적으로 관리하는 거대한 물리적 저장소입니다. 이는 운영체제가 가상 메모리를 통해 물리 RAM을 관리하는 방식과 놀라울 정도로 흡사한 하드웨어 수준의 가상화입니다.

![](/assets/img/2026-01-13-15-35-26.png)

### 비순차 실행을 위한 리오더 버퍼(ROB)

레지스터 리네이밍을 통해 명령어들이 순서를 앞질러 실행(Out-of-Order)되기 시작하면, 새로운 문제가 발생합니다. 바로 '예외 처리'와 '커밋(Commit)'의 순서입니다. 실행은 제멋대로 하더라도, 프로그램의 최종 상태는 반드시 코드에 적힌 순서대로 반영되어야 합니다.

이를 위해 **리오더 버퍼(ROB, Reorder Buffer)**가 동원됩니다. 비순차적으로 완료된 연산 결과들은 일단 ROB에 임시 저장되며, 가장 오래된 명령어부터 순서대로 레지스터 파일의 최종 상태를 확정(Commit) 짓습니다. 만약 중간에 분기 예측이 틀리거나 예외가 발생하면, ROB에 쌓인 비순차 결과들을 즉시 폐기하고 RAT를 이전 상태로 되돌림으로써 시스템의 무결성을 보장합니다.

> **물리 레지스터 풀의 고갈과 성능 저하**
> 
> 리네이밍은 강력하지만 물리 레지스터의 개수는 유한합니다. 너무 많은 명령어가 비순차적으로 대기하게 되면 물리 레지스터가 바닥나고, 결국 리네이밍 단계에서 파이프라인이 정지(Stall)하게 됩니다. 현대 CPU 설계자들이 다이 면적을 희생하면서까지 물리 레지스터 개수를 계속 늘리는 이유가 바로 여기에 있습니다.
{: .prompt-warning }

## Summary

레지스터는 단순히 CPU 내부에 존재하는 가장 빠른 메모리를 넘어, 하드웨어와 소프트웨어가 교차하는 최전선의 인터페이스입니다. 물리적 지연 시간을 극복하기 위해 계층 구조의 정점에 섰으며, 플립플롭과 멀티 포트 설계를 통해 찰나의 순간에 데이터를 공급합니다. 현대 아키텍처는 여기서 한 발 더 나아가 리네이밍과 가상화를 통해 논리적 한계를 뛰어넘는 병렬성을 구현해냈습니다. 결국 레지스터의 진화는 '어떻게 하면 연산 장치가 단 1초도 쉬지 않게 데이터를 밀어넣을 것인가'에 대한 엔지니어링적 응답입니다.

## References

* [[Wikipedia] Register file](https://en.wikipedia.org/wiki/Register_file)
* [[Wikipedia] Operand forwarding](https://en.wikipedia.org/wiki/Operand_forwarding)
* [[Medium] Out of Order Execution with Precise Exceptions](https://enesharman.medium.com/out-of-order-execution-with-precise-exceptions-9aea9225b75f)
* [[Wikipedia] Register allocation](https://en.wikipedia.org/wiki/Register_allocation)
* [[PlanetScale] Processes and Threads](https://planetscale.com/blog/processes-and-threads)