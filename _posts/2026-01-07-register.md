---
layout: post
title: "[Computer Structure] Register"
date: 2026-01-07 10:26 +0900
categories:
- Computer Science
- Operating System & Computer Structure
tags:
- Computer Structure
- Register
image:
    path: /assets/img/2026-01-07-12-26-08.png
---

## 🧩 Register

하드웨어와 소프트웨어가 만나는 최전선인 레지스터는 CPU가 현재 무엇을 하고 있는지를 증명하는 유일한 물리적 실체입니다. 단순히 빠른 저장소를 넘어, 전기적 신호를 유의미한 데이터로 보존하는 레지스터의 원론적 메커니즘을 파헤칩니다.

### 데이터의 영속성과 플립플롭(Flip-flop) 회로

컴퓨터 내부에서 데이터의 실체는 전위차에 불과하며, 이를 소프트웨어가 제어 가능한 '상태'로 유지하기 위해서는 물리적인 고정 장치가 필요합니다. 레지스터의 최소 단위인 플립플롭(Flip-flop) 회로는 논리 게이트들을 서로의 출력이 입력으로 되돌아오는 궤환(Feedback) 구조로 설계하여 이를 해결합니다.

플립플롭은 외부에서 특정 신호가 입력되기 전까지 현재의 전압 상태를 유지하려는 관성을 가집니다. 이를 통해 전력이 공급되는 동안 1비트의 논리적 상태(0 또는 1)를 반영구적으로 보존할 수 있습니다. 특히 레지스터는 트랜지스터 6개(6T)가 서로 맞물려 상태를 고정하는 SRAM 기술을 기반으로 하는데, 이는 논리 회로의 전류 흐름만으로 데이터를 유지하므로 연산 장치가 대기 시간 없이 즉각 접근하는 '0 클록 사이클' 속도를 보장합니다.

레지스터의 데이터는 CPU의 클록 신호가 진동하는 에지(Edge)에 맞춰 값이 고정되는 래칭(Latching) 과정을 거칩니다. 이 메커니즘은 무질서하게 흐르는 전기 신호를 컴퓨터의 '시간 단위'와 동기화하여, 정확한 타이밍에 데이터를 인출하고 저장할 수 있게 만듭니다.

```text
// 하드웨어 설명 언어(HDL)의 관점에서 본 레지스터 래칭 동작 원리
// 클록의 상승 에지(Positive Edge)에서만 입력 데이터가 상태로 저장됨

always @(posedge clock) begin
    if (reset) begin
        register_state <= 1'b0; // 리셋 시 상태 초기화
    end else if (enable) begin
        register_state <= input_data; // 클록 에지에서 전압 신호를 상태로 고정(Latch)
    end
end
```

결국 위와 같은 하드웨어 레벨의 동작은 회로의 물리적 근접성과 SRAM의 정적인 특성에서 기인합니다. 이는 CPU가 연산을 수행하는 찰나의 순간에 데이터가 유실되지 않도록 보장하며, 복잡한 명령어 집합이 물리적인 전하의 이동을 통해 논리적으로 완결될 수 있게 만드는 핵심적인 장치가 됩니다.

### 폰 노이만 병목과 레지스터의 필연성

![](/assets/img/2026-01-07-12-05-20.png)

현대 컴퓨팅 아키텍처에서 레지스터는 선택이 아닌 생존을 위한 아키텍처적 결단입니다. 폰 노이만 구조는 데이터와 명령어를 메모리에서 가져오는 방식을 취하는데, 여기서 CPU 연산 속도와 메모리 전송 속도 사이의 거대한 간극인 폰 노이만 병목(Von Neumann Bottleneck)이 발생합니다.

프로세서의 연산 주파수가 기하급수적으로 상승하는 동안 메모리 버스의 대역폭과 지연 시간은 물리적 한계로 인해 상대적으로 정체되었으며, 이 현상은 연산 장치가 데이터를 기다리며 멈춰 서는 '메모리 벽(Memory Wall)' 문제를 야기했습니다. 만약 CPU 내부에 레지스터라는 초고속 저장소가 없다면, 현대의 고성능 프로세서는 연산 시간의 대부분을 메모리로부터 응답이 오기만을 기다리는 데 낭비하게 될 것입니다.

이러한 병목을 해소하기 위해 모든 연산의 피연산자(Operand)를 반드시 레지스터에 올려두고 처리하는 Register-Register 아키텍처가 확립되었습니다. x86-64 아키텍처 역시 메모리의 데이터를 직접 연산하기보다 레지스터로 로드(Load)한 뒤 처리하고 다시 저장(Store)하는 방식을 지향합니다. 결국 레지스터는 하드웨어 수준에서의 데이터 로컬리티를 극대화하여, 소프트웨어의 논리가 물리적인 전송 지연에 가로막히지 않고 실행될 수 있도록 보장하는 최후의 보루입니다.

> **물리적 실체로서의 데이터**
> 
> 우리가 변수에 값을 대입하는 행위는 물리적으로 수많은 트랜지스터가 정해진 전압을 유지하기 위해 상호 잠금 회로를 구동시키는 일입니다. 레지스터를 이해한다는 것은 추상적인 '코드'가 어떻게 물리적인 '전하의 상태'로 박제되는지, 그리고 그 박제된 상태가 어떻게 연산의 토대가 되는지 그 인과관계를 장악하는 일입니다.
{: .prompt-tip }

## Architecture

소프트웨어의 논리적 명령이 실제 물리적 연산으로 전환되는 과정은 CPU 내부의 복잡한 데이터 경로(Data Path)를 가로지르는 전기 신호의 이동으로 정의됩니다. 레지스터는 이 경로의 시작점이자 종착점으로서, 연산 장치 및 제어 장치와 유기적으로 결합하여 프로그램의 실행력을 확보합니다.

### ALU와 레지스터의 물리적 결합

![](/assets/img/2026-01-07-12-33-36.png)

CPU가 산술 또는 논리 연산을 수행하기 위해서는 연산의 대상이 되는 피연산자(Operand)가 연산 장치(ALU)의 입력단에 물리적으로 도달해야 합니다. 이때 범용 레지스터(GPR)는 ALU와 내부 버스(Internal Bus)로 직접 연결되어 연산에 필요한 데이터를 즉각적으로 공급합니다.

명령어에 명시된 레지스터 번호에 따라 선택 회로(Multiplexer)가 작동하면, 해당 레지스터에 보관되어 있던 전기적 상태가 ALU의 입력 포트로 흘러 들어갑니다. ALU는 제어 장치로부터 받은 연산 코드(Opcode)에 따라 덧셈, 뺄셈 또는 논리 연산을 수행하며, 그 결과값은 다시 내부 버스를 타고 목적지 레지스터로 회귀합니다. 이를 '데이터 피드백(Data Feedback)' 메커니즘이라 부르며, 연산의 결과가 다음 명령어의 피연산자로 즉시 활용될 수 있게 만드는 핵심적인 순환 구조를 형성합니다.

```text
/* ALU 연산과 레지스터 피드백의 하드웨어 수준 흐름 (Pseudocode) */

// 1. 명령어 해독: ADD RAX, RBX
// 2. 소스 레지스터 선택 및 ALU 입력 (Operand Flow)
alu_in_a = register_file["RAX"];
alu_in_b = register_file["RBX"];

// 3. ALU 연산 수행 및 상태 플래그 세팅
alu_result = alu_in_a + alu_in_b;
rflags.zero = (alu_result == 0);
rflags.sign = (alu_result < 0);

// 4. 결과값의 회귀 (Write-back Stage / Feedback)
// 다음 클록 에지에서 RAX 레지스터의 전압 상태가 alu_result로 고정됨
register_file["RAX"] = alu_result; 

/* * 이 과정이 단일 클록 사이클 내에서 혹은 파이프라인의 각 단계에서 
 * 원자적으로 일어남으로써 소프트웨어의 연속성이 보장됩니다.
 */
```

결국 레지스터와 ALU의 결합은 하드웨어 수준에서의 '연산의 즉각성'을 보장하기 위한 설계입니다. 메인 메모리를 거치지 않고 CPU 내부의 고속 경로만을 이용함으로써, 프로세서는 매 사이클마다 지연 없이 복잡한 수식 연산을 이어 나갈 수 있는 물리적 토대를 갖게 됩니다.

### 흐름을 결정하는 제어 장치와의 협업

데이터가 흐르는 길을 만드는 것이 레지스터와 ALU의 결합이라면, 그 흐름의 방향과 타이밍을 결정하는 것은 제어 장치와 특수 목적 레지스터들의 협업입니다. 특히 RIP와 RFLAGS는 프로그램의 정적인 코드가 역동적인 실행 흐름으로 변모하는 과정에서 이정표 역할을 수행합니다.

프로그램의 생명력은 **RIP(Instruction Pointer)** 레지스터의 끊임없는 갱신에서 기인합니다. CPU는 매 명령어 인출(Fetch) 사이클마다 RIP가 가리키는 주소의 메모리에서 명령어를 가져오며, 인출 직후 RIP는 다음 명령어의 위치로 자동 증가합니다. 만약 조건문이나 루프와 같은 비선형적 흐름이 발생하면, 제어 장치는 RIP의 값을 강제로 수정하여 프로그램의 실행 지점을 도약시킵니다. 이때 판단의 근거가 되는 것이 바로 **RFLAGS(Flag Register)**입니다. ALU에서 수행된 연산의 결과가 0이었는지(Zero), 부호가 바뀌었는지(Sign) 등의 물리적 상태가 RFLAGS의 각 비트에 각인되며, 제어 장치는 이 비트들을 참조하여 다음에 실행할 RIP 값을 결정합니다.

또한, CPU 내부와 외부 메모리 사이의 거대한 속도 격차를 완충하기 위해 **MAR(Memory Address Register)**과 **MBR(Memory Buffer Register)**이 문지기 역할을 수행합니다. 연산에 필요한 데이터의 주소는 MAR에, 실제 데이터 값은 MBR에 안착되어 시스템 버스를 통해 메모리와 통신합니다. 이러한 인터페이스 레지스터들은 CPU의 초고속 연산 리듬이 상대적으로 느린 메인 메모리의 물리적 한계에 동기화되지 않고 독립적으로 기능할 수 있도록 보호하는 전략적 완충 지대가 됩니다.

> **하드웨어 클록과 상태 전이의 미학**
> 
> 우리가 작성한 `if` 문은 하드웨어 레벨에서 보면 ALU가 RFLAGS의 비트를 세팅하고, 제어 장치가 그 비트를 읽어 RIP의 전압 상태를 바꾸는 물리적 전이 과정입니다. 이 모든 일은 단 몇 나노초(ns) 안에 정해진 클록 리듬에 맞춰 오차 없이 일어납니다. 레지스터 아키텍처를 깊이 이해한다는 것은 단순히 이름과 용량을 외우는 것이 아니라, 전하의 이동이 어떻게 논리적인 판단으로 치환되는지 그 긴밀한 인과관계를 장악하는 과정입니다.
{: .prompt-tip }

## 커널이 장악하는 물리적 문맥

운영체제가 하드웨어를 통제하고 프로세스 간의 독립성을 보장하는 힘은 추상적인 소프트웨어 로직이 아닌, CPU 내부의 특정 레지스터들이 가진 '물리적 구속력'에서 나옵니다. 커널은 레지스터의 비트 단위 설정을 통해 권한을 격리하고, 메모리 지도를 실시간으로 교체하며 시스템의 질서를 유지합니다.

### 실행 권한과 주소 공간의 물리적 강제

커널 모드와 유저 모드를 가르는 경계는 소프트웨어의 판단이 아닌 하드웨어 레지스터의 상태에 의해 결정됩니다. x86 아키텍처에서 **CS(Code Segment) 레지스터**는 현재 실행 중인 코드 세그먼트의 정보를 담고 있으며, 이 레지스터의 하위 2비트인 **CPL(Current Privilege Level)**이 시스템의 실제 권한 레벨을 정의합니다.

* **권한의 물리적 격리**: CPL이 0(Ring 0)일 때만 CPU는 입출력 장치 제어나 시스템 레지스터 수정과 같은 특권 명령어(Privileged Instructions)를 실행합니다. 유저 모드(Ring 3)에서 이러한 명령을 시도하면 CPU 하드웨어는 즉시 예외(Exception)를 발생시켜 커널로 제어권을 넘깁니다. 이는 소프트웨어가 우회할 수 없는 물리적인 장벽 역할을 수행합니다.
* **메모리 지도의 동적 교체**: 각 프로세스는 자신만의 독립된 가상 주소 공간을 가지며, 이를 실체화하는 것이 **CR3 레지스터**입니다. CR3는 현재 활성화된 페이지 테이블의 물리 주소를 저장합니다. 운영체제가 컨텍스트 스위칭 시 CR3의 값을 새로운 프로세스의 주소로 덮어쓰는 순간, 하드웨어의 주소 변환 방식이 즉각적으로 변경되어 다른 프로세스의 메모리 영역에 접근하는 것이 원천적으로 차단됩니다.

이처럼 레지스터는 운영체제가 수립한 보안 정책이 실제 전기 신호 수준에서 강제력을 갖게 만드는 최후의 집행관과 같습니다.

### 컨텍스트 스위칭의 본질: 레지스터 덤프(Dump)

![](/assets/img/2026-01-07-12-01-55.png)

'프로세스가 멈춘다'는 현상의 실체는 CPU 내부에 머물던 전기적 상태인 레지스터 값들이 메모리로 쫓겨나 정적인 데이터로 변하는 과정입니다. 운영체제는 이 '박제'와 '복원'의 과정을 통해 시분할 가상화를 실현합니다.

스케줄러에 의해 실행 대상이 바뀌면 커널은 현재 실행 중인 프로세스의 범용 레지스터, 플래그 레지스터, 그리고 스택 포인터 등을 해당 프로세스의 **PCB(Process Control Block)**나 커널 스택에 저장합니다. 이후 새로 실행할 프로세스의 저장된 레지스터 상태를 CPU로 로드하면, CPU는 중단되었던 시점의 논리적 상태를 그대로 회복하여 연산을 이어갑니다. 이 일련의 작업은 극도로 정교하게 설계된 어셈블리 코드를 통해 수행됩니다.

```text
# x86-64 커널 내부의 컨텍스트 스위칭 개념 (OSTEP 메커니즘 기반)
# switch_context(struct thread *prev, struct thread *next)

switch_context:
    # 1. 현재(prev) 프로세스의 실행 상태를 커널 스택에 저장 (Register Dump)
    pushq %rbp
    pushq %rbx
    pushq %r12
    pushq %r13
    pushq %r14
    pushq %r15
    pushfq                  # 플래그 레지스터(RFLAGS) 저장

    # 2. 현재 스택 포인터(RSP)를 prev의 PCB 구조체에 저장
    movq %rsp, (%rdi)

    # 3. 다음(next) 프로세스의 PCB에서 스택 포인터(RSP)를 복구
    movq (%rsi), %rsp

    # 4. 다음 프로세스의 스택에 저장되어 있던 레지스터들을 CPU로 복원
    popfq                   # RFLAGS 복원
    popq %r15
    popq %r14
    popq %r13
    popq %r12
    popq %rbx
    popq %rbp

    # 5. 리턴 시 스택 상단의 복귀 주소로 점프하며 문맥 전환 완료
    ret
```

특히 외부 인터럽트나 시스템 콜에 의해 발생하는 **Trap 핸들링** 과정에서 하드웨어는 더욱 기민하게 움직입니다. 하드웨어는 소프트웨어의 개입 없이도 원자적(Atomic)으로 유저 모드의 RIP, RFLAGS, RSP 등을 커널 스택에 자동으로 저장(Push)합니다. 이는 커널이 유저의 실행 문맥을 오염시키지 않고 안전하게 제어권을 획득하기 위한 하드웨어 수준의 배려이자 필수적인 보호 장치입니다.

> **레지스터의 박제와 시스템의 연속성**
> 
> 컨텍스트 스위칭 과정에서 레지스터를 저장하고 복원하는 행위는 영화의 필름 조각을 이어 붙이는 것과 유사합니다. 하드웨어 입장에서는 매 순간 레지스터에 담긴 값에 따라 충실히 연산할 뿐이지만, 커널이 그 값을 교묘하게 갈아 끼움으로써 사용자에게는 여러 프로그램이 동시에 살아 움직이는 것처럼 느껴지게 만듭니다. 레지스터의 상태 보존이 완벽하지 않다면 시스템의 논리적 연속성은 순식간에 붕괴됩니다.
{: .prompt-tip }

## Summary

레지스터는 단순히 CPU 내부에 위치한 빠른 메모리가 아니라, 하드웨어의 물리적 한계를 극복하고 운영체제의 논리적 통제권을 실체화하는 시스템의 핵심 자산입니다.

| 구분                  | 주요 내용                            | 비고                                         |
| :-------------------- | :----------------------------------- | :------------------------------------------- |
| **물리적 본질**       | SRAM 기반의 플립플롭 회로 구조       | 0 클록 사이클 접근 및 전기적 상태 유지       |
| **아키텍처적 필연성** | 폰 노이만 병목 및 메모리 벽 극복     | 연산 지연 은폐를 위한 데이터 로컬리티 최상단 |
| **제어 메커니즘**     | RIP, RFLAGS를 통한 흐름 및 판단 제어 | 프로그램의 동적 실행 및 논리적 분기 강제     |
| **OS 통제권**         | CPL(권한) 및 CR3(주소 공간) 관리     | 하드웨어 수준의 프로세스 격리 및 보호 구현   |
| **문맥 전환**         | 레지스터 셋의 물리적 덤프 및 복원    | 실행 문맥(Context)의 물리적 실체             |

### 핵심 엔지니어링 체크포인트
- **데이터는 물리적 상태다**: 모든 소프트웨어 변수의 실체는 결국 레지스터 내부 트랜지스터들의 전압 상태이며, 클록 에지에 맞춰 고정(Latching)되는 물리적 현상입니다.
- **격리는 하드웨어가 보장한다**: 운영체제가 정의한 유저와 커널의 경계는 CS 레지스터의 CPL 비트와 CR3 레지스터라는 물리적 장벽에 의해 강제됩니다.
- **최적화의 물리적 한계**: 레지스터 리네이밍과 같은 가상화 기술이 존재하더라도, 물리적 레지스터의 한정된 자원은 시스템 처리량의 근본적인 임계점으로 작용합니다.

레지스터의 동작 원리를 장악하는 것은 하드웨어의 박동이 어떻게 운영체제의 지휘 아래 일사불란한 논리로 변모하는지를 이해하는 첫걸음입니다.

## References

* **[OSTEP]** Operating Systems: Three Easy Pieces - [Limited Direct Execution & CPU Mechanisms](https://web.archive.org/web/20240130181249/https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf)
* **[Intel SDM]** [Intel® 64 and IA-32 Architectures Software Developer’s Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
* **[CSE502]** [Computer Architecture - Out-of-Order Execution & Register Renaming](chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://compas.cs.stonybrook.edu/~nhonarmand/courses/sp16/cse502/slides/08-superscalar_ooo.pdf)
* **[System V ABI]** [x86-64 Architecture Processor Supplement](https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build)