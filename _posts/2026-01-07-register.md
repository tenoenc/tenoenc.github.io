---
layout: post
title: "[Computer Structure] Register"
date: 2026-01-07 10:26 +0900
math: true
categories:
- Computer Science
- Operating System & Computer Structure
tags:
- Computer Structure
- Register
image:
    path: /assets/img/2026-01-10-17-16-25.png
---

주방의 요리사가 식재료를 창고에서 조리대로, 다시 도마 위로 옮기는 과정은 OS가 데이터를 다루는 과정과 놀라울 정도로 닮았습니다. 하드디스크가 먼 식재료 창고이고 RAM이 넓은 조리대라면, **레지스터(Register)**는 요리사가 식재료를 썰거나 냄비를 젓는 그 순간 '손'안에 쥐고 있는 상태입니다. 아무리 넓은 조리대(RAM)가 있어도 요리사의 손이 멈추면 요리는 중단됩니다. CPU라는 위대한 엔진이 굴러가는 톱니바퀴의 가장 안쪽, 그 찰나의 기억이 어떻게 시스템 전체의 생사를 결정하는지 파헤쳐 봅니다.

## 🧩 Logic Gate (Flip-Flop)

운영체제라는 거대한 소프트웨어 아키텍처를 지탱하는 가장 밑바닥에는 '전기적 상태를 유지하려는 관성'이 존재합니다. 우리는 이를 메모리라고 부르지만, CPU 내부에서 이 기능은 **플립플롭(Flip-Flop)**이라는 논리 회로를 통해 실현됩니다.

### 전기가 기억으로 변하는 순간

트랜지스터는 단순히 전기를 흐르게 하거나 끊는 스위치에 불과합니다. 하지만 이 스위치들을 교묘하게 엇갈려 배치(Cross-coupled)하면, 외부에서 신호가 오기 전까지 현재의 0 또는 1 상태를 유지하는 '피드백 루프'가 형성됩니다. 이것이 바로 **SR 래치(Latch)**의 기본 원리입니다.

OSTEP(Operating Systems: Three Easy Pieces)의 관점에서 보면, 이러한 하드웨어적 래칭 메커니즘은 OS가 프로세스의 상태를 유지할 수 있게 하는 물리적 확신을 제공합니다. 전자가 흐르는 속도와 거의 동일한 속도로 데이터를 가둘 수 있다는 점이 레지스터를 모든 메모리 계층의 정점에 서게 만듭니다.

![](/assets/img/2026-01-10-16-56-23.png)

### 비휘발성의 경계와 클럭의 통제

단순한 래치는 데이터가 언제 바뀔지 모르는 불안정성을 가집니다. 이를 통제하기 위해 CPU의 심장 박동인 **클럭(Clock)** 신호가 도입됩니다. **D-플립플롭**은 오직 클럭이 상승하는 그 짧은 순간(Edge-triggering)에만 입력값을 복사하여 저장합니다. 

이 '박자'에 맞춘 데이터 저장은 CPU 파이프라인의 각 스테이지가 서로 충돌하지 않고 데이터를 주고받을 수 있게 만드는 핵심 규약이 됩니다. OS가 스레드를 실행할 때, 우리는 논리적인 흐름을 보지만 하드웨어는 이 플립플롭의 박동에 맞춰 수십억 번의 데이터 복사를 수행하고 있는 것입니다.

> **Edge-Triggering**
> 
> 레지스터가 레벨(Level)이 아닌 에지(Edge)에서 동작한다는 사실은 매우 중요합니다. 이는 데이터의 입력과 출력을 격리하여, 같은 클럭 사이클 내에서 데이터가 무한 루프에 빠져 파괴되는 현상을 방지합니다.
{: .prompt-info }

## 🧩 Register

플립플롭이 1비트를 기억하는 최소 단위라면, 이들을 32개 또는 64개씩 묶어 병렬로 배치한 것이 우리가 부르는 **레지스터(Register)**입니다.

### CPU 내부에 흐르는 찰나의 데이터

레지스터는 ALU(산술논리연산장치)와 물리적으로 가장 가까운 곳에 위치합니다. 단순히 가까운 것을 넘어, ALU의 입력 포트와 레지스터의 출력 포트는 전선(Bus)으로 직접 연결되어 있습니다. RAM에서 데이터를 가져오려면 주소 버스를 태우고 메모리 컨트롤러를 거쳐 수십 나노초를 기다려야 하지만, 레지스터는 0.1나노초 이내에 결과를 내놓습니다.

이 속도의 격차 때문에 현대 CPU 설계의 핵심은 "어떻게 하면 데이터를 메모리에 보내지 않고 레지스터 안에서만 놀게 할 것인가"에 집중됩니다.

![](/assets/img/2026-01-10-16-56-31.png)

### 범용 레지스터(GPR)와 특수 목적 레지스터(SPR)의 역할 분담

모든 레지스터가 프로그래머의 자유로운 도화지는 아닙니다. 용도에 따라 엄격히 구분됩니다.

* **General Purpose Registers (GPR)**: `rax`, `rbx`, `rcx` 등 연산의 중간 결과나 주소를 담는 다목적 저장소입니다. OS는 컨텍스트 스위칭 시 이 값들을 가장 우선적으로 보호해야 합니다.
* **Special Purpose Registers (SPR)**: CPU의 현재 상태를 제어합니다.
    * **Instruction Pointer (RIP)**: 다음에 실행할 명령어의 메모리 주소를 가리킵니다. OS가 '실행 흐름'을 제어한다는 것은 결국 이 RIP 값을 바꾸는 행위입니다.
    * **Stack Pointer (RSP)**: 현재 프로세스의 스택 최상단을 가리키며, 함수 호출과 로컬 변수의 생존 범위를 결정합니다.

운영체제는 이러한 레지스터들의 집합(Register Set)을 각 프로세스에게 마치 자신만이 소유한 것처럼 속이는 '추상화의 마술'을 부립니다. 하지만 물리적으로는 단 한 세트(혹은 코어당 한 세트)만 존재할 뿐이며, 이 한정된 자원을 뺏고 뺏기는 과정이 바로 멀티태스킹의 실체입니다.

## 🧩 Instruction Set Architecture (ISA)

소프트웨어가 하드웨어에게 건네는 약속의 언어, **ISA(명령어 집합 구조)**는 운영체제와 컴파일러가 레지스터를 어떻게 바라봐야 하는지 정의하는 명세서입니다. OS가 "이 값은 `rax`에 저장해"라고 명령할 때, 하드웨어는 그 이름을 보고 물리적인 전기 신호를 어디로 보낼지 결정합니다.

### 소프트웨어가 하드웨어에 건네는 약속의 언어

컴퓨터 공학에서 아키텍처를 설계할 때 가장 먼저 결정하는 것은 "우리가 이름을 붙여 사용할 수 있는 레지스터가 몇 개인가?"입니다. 이를 **아키텍처 레지스터(Architectural Registers)**라고 부릅니다. 

Red Hat의 아키텍처 분석에 따르면, ISA는 단순히 명령어의 나열이 아니라 하드웨어 자원의 추상화 계층입니다. 프로그래머가 메모리 주소를 일일이 계산하는 대신 레지스터 이름을 사용하는 순간, 하드웨어는 내부적으로 복잡한 최적화를 수행할 수 있는 재량권을 얻게 됩니다. 레지스터는 소프트웨어와 하드웨어 사이의 '완충지대'이자 '공통 언어'인 셈입니다.

### x86-64와 ARM의 레지스터 활용 전략 비교

현대 컴퓨팅의 양대 산맥인 x86-64(CISC)와 ARM(RISC)은 레지스터를 다루는 철학부터 극명하게 갈립니다.

* **x86-64 (The Legacy of Constraints)**: 역사적으로 레지스터 개수가 부족했던 x86은 메모리에서 직접 값을 가져와 연산하는 명령어가 많습니다. `add [mem], eax`와 같은 명령어는 메모리 접근과 산술 연산을 한 번에 수행합니다. 이는 코드 밀도를 높이지만, CPU 내부 파이프라인 설계를 복잡하게 만듭니다.
* **ARM (Load/Store Architecture)**: RISC의 정수인 ARM은 모든 연산을 오직 레지스터 사이에서만 수행합니다. 메모리에 접근하는 명령어는 오직 `LDR`(Load)과 `STR`(Store)뿐입니다. 연산을 하려면 반드시 메모리에서 레지스터로 값을 먼저 옮겨야 합니다.

```text
; --- x86-64 (CISC: Memory-to-Register allowed) ---
; rax 레지스터에 [rbp-8] 주소의 메모리 값을 직접 더합니다.
; 단 한 줄의 명령어로 메모리 접근과 연산이 동시에 일어납니다.
add rax, qword ptr [rbp-8]


; --- ARM64 (RISC: Load/Store Architecture) ---
; ARM은 모든 연산을 레지스터 사이에서만 수행해야 합니다.
; 1. 먼저 메모리에서 값을 레지스터(x1)로 읽어옵니다.
ldr x1, [x0]
; 2. 그 후 레지스터끼리 더하여 최종 결과(x2)를 산출합니다.
add x2, x2, x1
```

이러한 설계 차이는 OS의 컨텍스트 스위칭 비용에도 영향을 미칩니다. ARM은 더 많은 범용 레지스터(31개)를 가지므로 한 번에 더 많은 데이터를 레지스터에 상주시켜 성능을 끌어올리지만, 스레드 전환 시 보관해야 할 레지스터의 양이 늘어나는 트레이드오프가 발생합니다.

## 🧩 CPU Pipeline

CPU가 단일 명령어를 처음부터 끝까지 수행하고 다음 명령어를 기다린다면, 현대의 압도적인 연산 속도는 불가능했을 것입니다. 이를 해결하는 기법이 **파이프라인(Pipeline)**이며, 레지스터는 이 파이프라인의 각 단계를 이어주는 '동기화의 벽' 역할을 합니다.

### 레지스터가 컨베이어 벨트의 스테이션이 될 때

명령어 하나가 실행되기 위해 Fetch, Decode, Execute, Memory, Write-back의 5단계를 거친다고 가정해 봅시다. 각 단계 사이에는 반드시 **파이프라인 레지스터(Pipeline Register)**가 존재해야 합니다. 

만약 단계 사이에 레지스터가 없다면, 전구의 빛이 번지듯 전기 신호가 겹쳐 데이터가 오염될 것입니다. 레지스터는 클럭의 에지에 맞춰 앞 단계의 결과물을 '박제'하여 다음 단계로 넘겨주는 댐 역할을 수행합니다. 덕분에 CPU는 첫 번째 명령어가 실행 중일 때, 두 번째 명령어를 해석하고, 세 번째 명령어를 읽어오는 병렬 처리를 수행할 수 있습니다.

![](/assets/img/2026-01-10-16-56-45.png)

### 파이프라인 해저드와 레지스터 포워딩(Forwarding) 기술

하지만 파이프라인에는 치명적인 약점이 있습니다. 앞선 명령어가 레지스터에 결과를 다 쓰기도 전에, 다음 명령어가 그 값을 필요로 하는 경우입니다. 이를 **데이터 해저드(Data Hazard)**라고 부릅니다.

> **기다림은 사치다: Register Forwarding**
> 
> 결과값이 최종적으로 레지스터 파일에 기록될 때까지 기다리는 대신, ALU 연산이 끝나자마자 그 결과 신호를 전선(Bypass)을 통해 다음 명령어로 직접 쏴주는 기술입니다. 하드웨어 엔지니어들은 이를 '지름길'이라고 부르며, 레지스터 기록 절차를 생략함으로써 파이프라인의 멈춤(Stall)을 최소화합니다.
{: .prompt-tip }

OS는 이러한 하드웨어의 미시적인 동작에 직접 관여하지는 않지만, 컴파일러는 이 해저드를 피하기 위해 명령어의 순서를 재배치(Instruction Scheduling)합니다. 결국 소프트웨어 최적화의 끝은 레지스터의 데이터 흐름을 얼마나 매끄럽게 만드느냐에 달려 있습니다.

## Register State & Context Switching

운영체제의 가장 위대한 기만 중 하나는 모든 프로세스가 자신이 CPU를 독점하고 있다고 믿게 만드는 것입니다. 이 마법을 가능하게 하는 실체가 바로 **레지스터 상태(Register State)**입니다. 프로세스가 실행 중이라는 것은, CPU의 레지스터들이 해당 프로세스의 데이터로 가득 차 활발히 변하고 있음을 의미합니다.

### OS가 스레드를 '일시정지' 시키는 물리적 방법

멀티태스킹 환경에서 OS는 수시로 실행 중인 스레드를 중단시키고 다른 스레드에게 CPU를 넘겨줍니다. 이때 '정지' 버튼을 누르는 순간의 모든 레지스터 값은 해당 프로세스의 **콘텍스트(Context)**가 됩니다. 

OSTEP에서 강조하는 '제한적 직접 실행(Limited Direct Execution)' 모델에 따르면, 타이머 인터럽트가 발생하는 순간 CPU는 현재 실행 중인 사용자 모드의 레지스터들을 커널 스택(Kernel Stack)에 자동으로 쏟아붓습니다. OS는 이 '박제된 상태'를 안전한 곳에 저장해 두었다가, 나중에 해당 스레드를 복구할 때 다시 레지스터 파일로 밀어 넣습니다. 

![](/assets/img/2026-01-10-16-56-55.png)

### 커널 스택과 레지스터 파일의 동기화 메커니즘

컨텍스트 스위칭의 오버헤드는 대부분 이 '레지스터 주고받기'에서 발생합니다. 단순히 값을 복사하는 행위를 넘어 이 과정에서 발생하는 캐시 오염(Cache Pollution)은 시스템 전체 성능에 영향을 미칩니다. 하지만 하드웨어는 타협하지 않습니다. 레지스터를 완벽히 복구하지 않으면, 프로그램은 자신이 중단되었던 지점의 논리를 이어갈 수 없기 때문입니다.

## Register Renaming & Out-of-Order Execution

우리가 어셈블리 코드를 볼 때 마주하는 `rax`, `rbx` 같은 이름들은 사실 하드웨어가 우리에게 보여주는 '가면'에 불과합니다. 이를 **논리적 레지스터(Logical Register)**라고 합니다. 하지만 현대 CPU 내부에는 이보다 훨씬 많은 수의 **물리적 레지스터(Physical Register)**가 숨겨져 있습니다.

### 데이터 의존성의 족쇄를 푸는 가상화 기법

명령어들이 순서대로 실행되지 않고 제각각 끝나는 **비순차 실행(Out-of-Order Execution)** 환경에서는 심각한 문제가 발생합니다. 예를 들어, 뒤에 오는 명령어가 앞선 명령어보다 먼저 실행되어 레지스터 값을 덮어써 버리면 데이터가 엉망이 됩니다. 

하드웨어는 이를 해결하기 위해 **레지스터 리네이밍(Register Renaming)**이라는 마법을 부립니다. 프로그래머가 `rax`라고 부르는 이름을, CPU 내부의 매핑 테이블(Mapping Table)이 비어 있는 물리적 레지스터 `P102`, `P145` 등으로 실시간으로 연결해 줍니다. 

![](/assets/img/2026-01-10-16-57-02.png)

### 물리적 레지스터와 논리적 레지스터의 매핑 아키텍처

이 기법을 통해 CPU는 이름만 같을 뿐 실제로는 상관없는 연산들을 병렬로 처리할 수 있게 됩니다. 이는 마치 OS가 가상 메모리를 통해 실제 RAM 주소를 숨기는 것과 소름 돋을 정도로 유사한 '하드웨어 차원의 가상화'입니다. 현대의 하이엔드 CPU는 단 16개의 x86 이름을 유지하기 위해 내부적으로 200개가 넘는 물리적 레지스터를 굴리며, 이를 통해 가짜 의존성(WAR, WAW)을 완전히 제거합니다.

> **하드웨어의 가상화**
> 
> 리네이밍은 소프트웨어가 하드웨어의 한정된 자원을 의식하지 않고 작성될 수 있도록 보장하는 최후의 방어선입니다. 컴파일러가 아무리 비효율적으로 레지스터를 할당하더라도, CPU는 리네이밍을 통해 내부적인 병렬성을 확보해 냅니다.
{: .prompt-tip }

## The Physics of Proximity & Hardware Friction

우리는 왜 수천 개, 혹은 수만 개의 레지스터를 가질 수 없을까요? RAM이 기가바이트 단위로 증설될 때, 레지스터가 여전히 수십 개 수준에 머물러 있는 이유는 탐욕이 부족해서가 아니라 **물리 법칙**이라는 거대한 벽 때문입니다.

### 빛의 속도와 다이(Die) 면적의 트레이드오프

레지스터의 본질은 'ALU 바로 옆'에 있어야 한다는 점입니다. 거리가 멀어지면 신호가 전달되는 물리적 시간이 길어지고, 이는 곧 클럭 속도의 저하로 이어집니다. 3GHz로 작동하는 CPU에서 1사이클 동안 전기가 이동할 수 있는 거리는 고작 수 센티미터에 불과하며, 회로 내부의 각종 지연 시간을 고려하면 실제 가용 거리는 밀리미터 단위로 좁혀집니다.

레지스터의 개수를 늘리려면 이를 선택하기 위한 디코딩 회로(Multiplexer)가 복잡해지고, 이는 필연적으로 다이 면적의 증가와 신호 경로의 연장을 초래합니다. 결국 '빠른 속도'를 위해 만든 레지스터가 '너무 많아지는 순간' 역설적으로 시스템을 느리게 만드는 하드웨어 마찰(Friction)이 발생하는 것입니다.

### 왜 우리는 1,000개의 레지스터를 가질 수 없는가

더 많은 레지스터는 더 많은 전력 소모와 발열을 의미합니다. 레지스터는 CPU에서 가장 빈번하게 스위칭이 일어나는 지점이며, 이 '열기'를 식히지 못하면 칩은 타버리고 맙니다. 엔지니어들은 수십 년간의 실험 끝에 **16~32개**라는 숫자가 성능과 물리적 제약 사이의 가장 달콤한 지점(Sweet Spot)임을 찾아냈습니다. 

![](/assets/img/2026-01-10-16-57-15.png)

## Compiler Strategy: Register Allocation & Spill Code

하드웨어가 물리적 한계를 설정했다면, 그 한계 안에서 예술을 부리는 것은 컴파일러의 몫입니다. 컴파일러는 코드 속의 수많은 변수 중 '누가 이 귀한 레지스터 자리를 차지할 자격이 있는가'를 결정하는 엄격한 오디션을 진행합니다.

### 한정된 자원을 배분하는 그래프 색칠 알고리즘

현대 컴파일러는 레지스터 할당을 위해 **그래프 색칠(Graph Coloring)** 알고리즘을 사용합니다. 
1. 각 변수의 생존 기간(Liveness)을 분석합니다.
2. 동시에 살아있어야 하는 변수들을 서로 선으로 잇습니다(Interference Graph).
3. 서로 연결된 노드끼리는 같은 색(레지스터)을 가질 수 없다는 조건하에 최소한의 색으로 그래프를 채웁니다.

이 문제는 컴퓨터 과학에서 유명한 NP-완전 문제지만, 컴파일러는 휴리스틱을 동원해 최적의 해에 근접합니다. 변수가 레지스터 개수보다 많아지는 순간, 누군가는 탈락하여 차가운 메모리(Stack)로 쫓겨나야 합니다.

### 스필 코드(Spill Code)가 시스템 성능에 미치는 치명적 영향

탈락한 변수를 메모리에 저장하고 나중에 다시 불러오는 코드를 **스필 코드(Spill Code)**라고 부릅니다. 이는 성능의 재앙입니다. 레지스터에 있으면 1사이클에 끝날 일이, 스필 코드가 발생하는 순간 수백 사이클의 메모리 대기 시간으로 돌변합니다.

```c
// [C Logic] 가상의 연산: 16개의 변수가 동시에 살아있어야 하는 루프
int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p;
// ... 복잡한 연산 수행 ...
```

```text
; --- 컴파일러가 생성한 Spill Code (x86-64 기준) ---
; 레지스터가 부족해지자 현재 rax에 있던 중요한 값을 스택(메모리)으로 대피시킵니다.
mov [rsp + 16], rax    ; <--- Spill Out (재앙의 시작)

; 새로운 연산을 위해 다른 변수를 메모리에서 읽어옵니다.
mov rbx, [rsp + 40]    ; 메모리 접근 발생 (느림)
add rax, rbx

; 아까 대피시켰던 값을 다시 사용하기 위해 메모리에서 불러옵니다.
mov rax, [rsp + 16]    ; <--- Spill In (추가 지연 발생)
```

운영체제 개발자나 고성능 서버 엔지니어들이 루프 내부의 변수 개수를 극도로 제한하거나, 인라인 함수를 신중하게 사용하는 이유도 바로 이 레지스터 압박(Register Pressure)을 줄여 스필 코드를 원천 차단하기 위함입니다.

> **레지스터와 컨텍스트 스위칭 비용**
> 
> 레지스터를 많이 쓰면 메모리 접근이 줄어들지만, 컨텍스트 스위칭 비용이 증가합니다. 반대로 적게 쓰면 스위칭은 빠르지만 실행 속도가 저하됩니다. 완벽한 정답은 없으며, 아키텍처의 설계 철학에 따른 최선의 타협점만 존재할 뿐입니다.
{: .prompt-warning }

## Summary

레지스터는 단순한 메모리의 연장선이 아니라, **하드웨어의 물리적 한계와 소프트웨어의 논리적 추상화가 충돌하고 타협하는 최전선**입니다. 

플립플롭이라는 전기적 관성에서 시작된 1비트의 기억은 파이프라인의 동기화를 유지하고, ISA라는 약속을 통해 소프트웨어에 전달됩니다. 운영체제는 이 한정된 자원을 '콘텍스트'라는 이름으로 박제하고 복구하며 멀티태스킹의 환상을 유지하고, CPU는 리네이밍 기술을 통해 이름뿐인 레지스터 뒤에 숨겨진 물리적 병렬성을 폭발시킵니다. 

결국 레지스터를 깊이 이해한다는 것은, 보이지 않는 전자의 흐름이 어떻게 우리가 작성한 코드의 한 줄이 되어 생명력을 얻는지 그 기원을 목격하는 일과 같습니다.

## References

* [[OSTEP] Operating Systems: Three Easy Pieces - Context Switching Mechanisms](https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf)
* [[Wikipedia] Register Renaming & Out-of-Order Execution](https://en.wikipedia.org/wiki/Register_renaming)
* [[PlanetScale] Processes and Threads — Context Switching State](https://planetscale.com/blog/processes-and-threads)
* [[HCL Tech] Register Allocation via Graph Coloring Strategy](https://www.hcltech.com/sites/default/files/documents/resources/whitepaper/files/register_allocation_via_graph_coloring_meena_jain_-_v2.0.pdf)
* [[Red Hat] Architectural Differences: ARM vs x86-64](https://www.redhat.com/en/topics/linux/ARM-vs-x86)