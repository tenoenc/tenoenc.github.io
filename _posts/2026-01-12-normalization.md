---
layout: post
title: "[DB Theory] Normalization"
date: 2026-01-12 14:30 +0900
math: true
categories:
- Computer Science
- Database Theory
tags:
- Database Theory
- Normalization
image:
    path: /assets/img/2026-01-13-14-35-06.png
---

## 🧩 Relation

데이터베이스 설계의 여정은 릴레이션(Relation)이라는 개념을 정확히 해부하는 것에서 시작합니다. 흔히 실무에서 '테이블'과 '릴레이션'을 혼용하여 부르곤 하지만, 정규화의 논리적 엄밀함을 확보하기 위해서는 이 둘을 철저히 구분해야 합니다. 테이블이 물리적인 저장 구조를 암시하는 용어라면, 릴레이션은 수학적 집합론에 뿌리를 둔 논리적 추상화입니다.

> **릴레이션의 수학적 본질**
> 
> 릴레이션은 본질적으로 튜플(Tuple)들의 집합입니다. 집합론의 특성에 따라 릴레이션 내에서 튜플의 순서는 의미가 없으며, 중복된 튜플 또한 존재할 수 없습니다. 모든 데이터는 유일하게 식별 가능해야 한다는 이 단순한 전제가 정규화의 대전제입니다.
{: .prompt-info }

### 수학적 집합과 릴레이션

릴레이션 모델의 창시자 E.F. Codd는 데이터를 관리하기 위해 집합론(Set Theory)의 n-항 릴레이션(n-ary Relation) 개념을 도입했습니다. 이는 단순히 행과 열을 맞추는 작업을 넘어, 각 속성(Attribute)이 가질 수 있는 값의 집합인 도메인(Domain)들의 데카르트 곱(Cartesian Product)의 부분 집합으로 릴레이션을 정의합니다.

예를 들어, 학번 도메인 $D_1$과 이름 도메인 $D_2$가 있다면, 이들의 데카르트 곱 $D_1 \times D_2$는 발생 가능한 모든 학번과 이름의 조합을 포함합니다. 실제 '학생' 릴레이션은 이 방대한 조합 중 현실 세계의 실체(Entity)와 일치하는 유효한 튜플들만을 선택적으로 보유하는 수학적 부분 집합입니다.

이러한 수학적 기초는 정규화 과정에서 릴레이션을 분해하거나 결합할 때, 데이터의 무손실성(Losslessness)을 증명하는 강력한 도구가 됩니다. 릴레이션 내의 모든 속성 값은 '원자적(Atomic)'이어야 한다는 원칙 역시 집합론적 단순성을 유지하기 위한 장치입니다. 리스트나 중첩된 구조를 허용하지 않는 이 엄격함이 오히려 데이터 구조의 예측 가능성을 극대화합니다.

![](/assets/img/2026-01-13-14-14-45.png)

### 스키마와 인스턴스의 정의

릴레이션을 이해하는 또 다른 축은 '정적인 구조'와 '동적인 상태'의 분리입니다. 이를 각각 스키마(Schema)와 인스턴스(Instance)라고 부릅니다.

1. **스키마(Schema)**: 릴레이션의 이름, 속성의 이름과 타입, 그리고 데이터가 준수해야 할 제약 조건(Integrity Constraints)을 정의하는 논리적 설계도입니다. 이는 '내포(Intension)'라고도 불리며, 시간이 지나도 쉽게 변하지 않는 데이터의 뼈대 역할을 합니다. 정규화는 바로 이 스키마를 최적화하여 논리적 모순을 제거하는 과정입니다.
2. **인스턴스(Instance)**: 특정 시점에 릴레이션에 존재하는 실제 튜플들의 집합입니다. 이는 '외연(Extension)'이라고도 하며, 데이터의 삽입, 삭제, 수정에 따라 끊임없이 변화합니다. 

엔지니어링 관점에서 중요한 지점은, 어떠한 인스턴스 변화 속에서도 스키마가 정의한 제약 조건은 반드시 유지되어야 한다는 점입니다. 릴레이션 모델은 인스턴스의 특정 행태에 의존하지 않고, 스키마의 구조적 정의만으로 데이터의 무결성을 담보할 수 있는 수학적 정당성을 부여합니다. 

결국 정규화란, 변화무쌍한 인스턴스를 수용하기 위해 가장 견고하고 흔들리지 않는 스키마를 설계하는 공학적 의사결정의 연속입니다. 속성 간의 논리적 결합도가 스키마 수준에서 완벽하게 정의될 때, 우리는 비로소 데이터의 엔트로피를 통제할 수 있게 됩니다.

## 🧩 Anomaly

정규화되지 않은 데이터 모델은 겉보기에 편리해 보일 수 있으나, 시간이 흐를수록 시스템의 무결성을 갉아먹는 '이상 현상(Anomaly)'이라는 대가를 치르게 됩니다. 이상 현상은 데이터의 중복성(Redundancy)이 논리적 일관성을 압도할 때 발생하는 설계의 부작용입니다. 마틴 파울러가 강조하듯, 나쁜 설계는 단순히 코드를 읽기 어렵게 만드는 것을 넘어, 데이터 자체가 스스로를 부정하게 만드는 모순의 늪으로 우리를 인도합니다.

> **이상 현상의 근본 원인**
> 
> 데이터베이스 내의 한 가지 사실(Fact)은 반드시 한 곳에만 존재해야 합니다. 만약 하나의 정보가 여러 튜플에 흩어져 존재한다면, 그 정보를 조작하는 모든 행위는 잠재적인 데이터 오염의 통로가 됩니다. 이상 현상은 바로 이 '중복된 사실'을 동기화하지 못해 발생하는 논리적 파열음입니다.
{: .prompt-warning }

### 삽입, 삭제, 갱신의 오류

정규화가 결여된 릴레이션에서 우리는 크게 세 가지 형태의 치명적인 이상 현상과 마주하게 됩니다.

1. **삽입 이상 (Insertion Anomaly)**: 새로운 데이터를 저장하려 할 때, 불필요하거나 원치 않는 정보까지 강제로 입력해야 하거나, 특정 데이터 없이는 삽입 자체가 불가능한 상황입니다. 예를 들어, '수강' 릴레이션에 학생 정보와 과목 정보가 섞여 있다면, 아직 과목을 신청하지 않은 신입생은 과목 번호(Primary Key의 일부)가 없다는 이유로 학적 시스템에 등록조차 할 수 없는 사태가 벌어집니다.
2. **삭제 이상 (Deletion Anomaly)**: 튜플을 삭제할 때, 삭제하려던 정보와는 무관한 유용한 정보까지 함께 소실되는 현상입니다. 위의 예시에서 특정 과목의 수강생이 단 한 명뿐일 때, 그 학생의 수강 취소 처리를 수행하면 해당 과목의 상세 정보(교수진, 강의실 등)까지 시스템에서 영구히 사라지게 됩니다. 이는 논리적으로 존재해야 할 엔티티가 부수적인 관계의 삭제로 인해 증발해버리는 정보의 비가역적 손실을 의미합니다.
3. **갱신 이상 (Update Anomaly)**: 중복된 튜플 중 일부만 수정되어 데이터 간 불일치가 발생하는 현상입니다. 학생의 전화번호가 변경되었을 때, 그 학생이 수강 중인 모든 튜플을 찾아 업데이트하지 못한다면, 시스템은 동일 인물에 대해 서로 다른 전화번호를 가진 여러 개의 '진실'을 보유하게 됩니다. 어떤 튜플을 조회하느냐에 따라 결과가 달라지는 '데이터 부패(Data Corruption)'의 시작점입니다.

### 데이터 무결성 파괴의 원인

이러한 현상들은 단순히 '불편함'의 문제가 아닙니다. 시스템의 신뢰도를 무너뜨리고, 애플리케이션 계층에서 복잡한 방어 로직을 강요하게 만듭니다. 데이터베이스 아키텍트는 이를 코드(Application level)로 해결하려 하기보다, 릴레이션의 구조적 분해를 통해 엔진(Database level) 수준에서 원천 차단해야 합니다.

이상 현상을 방치하면 데이터베이스는 더 이상 신뢰할 수 있는 'Source of Truth'가 아닌, 불확실성이 가득한 저장소로 전락합니다. 정규화는 바로 이러한 모순을 수학적으로 증명하고, 각 속성이 자신의 자리를 찾아가도록 재배치하는 정밀한 엔지니어링 작업입니다.

```sql
-- 1. 비정규화된 테이블 생성 (학번, 학생명, 과목번호, 과목명, 교수, 강의실)
-- PK는 (StudentID, CourseID)로 설정
CREATE TABLE CourseRegistration (
    StudentID INT,
    StudentName VARCHAR(50),
    CourseID VARCHAR(10),
    CourseName VARCHAR(50),
    Professor VARCHAR(50),
    Room VARCHAR(20),
    PRIMARY KEY (StudentID, CourseID)
);

-- 2. 삽입 이상 (Insertion Anomaly)
-- 상황: 신입생 '김철수'를 등록하고 싶지만, 아직 수강신청을 하지 않음.
-- 문제: CourseID가 PK의 일부이므로 NULL을 허용하지 않아 학생 정보만으로는 삽입 불가.
INSERT INTO CourseRegistration (StudentID, StudentName, CourseID) 
VALUES (2024001, '김철수', NULL); -- Error: Column 'CourseID' cannot be null

-- 3. 삭제 이상 (Deletion Anomaly)
-- 상황: '이영희' 학생이 유일하게 수강하던 'Database' 과목을 취소함.
-- 문제: 학생 정보를 삭제하면 'Database' 과목의 교수(안드레)와 강의실(B101) 정보까지 시스템에서 증발함.
DELETE FROM CourseRegistration WHERE StudentID = 2024002;
-- 결과적으로 'Database' 과목에 대한 모든 메타데이터가 사라짐.

-- 4. 갱신 이상 (Update Anomaly)
-- 상황: '안드레' 교수의 강의실이 'B101'에서 'C303'으로 변경됨.
-- 문제: 해당 교수의 과목을 듣는 모든 학생의 튜플을 수정해야 함. 하나라도 누락되면 데이터 불일치 발생.
UPDATE CourseRegistration SET Room = 'C303' 
WHERE Professor = '안드레' AND StudentID = 2024003; 
-- 2024004 학생의 튜플은 여전히 'B101'로 남아있어 논리적 모순 발생.
```

## 🧩 Functional Dependency

정규화라는 복잡한 수술을 집도하기 위해 아키텍트가 손에 쥐어야 할 가장 날카로운 메스(Scalpel)는 바로 **함수적 종속성(Functional Dependency, FD)**입니다. 릴레이션 내의 속성들이 서로 어떤 논리적 인과관계로 얽혀 있는지 파악하지 못한다면, 정규화는 단순히 테이블을 파편화하는 무의미한 작업에 그치고 맙니다.

함수적 종속성은 수학적으로 매우 엄밀한 토대 위에 서 있습니다. 릴레이션 $R$의 속성 집합을 $X$와 $Y$라고 할 때, 임의의 두 튜플 $t_1, t_2$에서 $X$의 값이 같다면($t_1[X] = t_2[X]$) 반드시 $Y$의 값도 같아야($t_1[Y] = t_2[Y]$) 합니다. 이때 우리는 "$Y$는 $X$에 함수적으로 종속된다"고 말하며, 이를 $X \to Y$로 표기합니다. 이는 단순히 데이터의 나열을 넘어, 현실 세계의 비즈니스 규칙이 데이터베이스 스키마에 투영되는 가장 구체적인 논리적 연결 고리입니다.

### 결정자와 종속자의 사상

이러한 함수적 종속성은 속성 간의 '결정론적 관계'를 의미합니다. 여기서 화살표의 시작점인 $X$를 **결정자(Determinant)**, 결과값인 $Y$를 **종속자(Dependent)**라고 부릅니다. 이는 수학의 함수 $y = f(x)$와 완벽히 궤를 같이 합니다. 입력값 $x$가 정해지면 결과값 $y$가 유일하게 결정되듯, 데이터베이스에서도 결정자의 값을 알면 종속자의 값을 유일하게 식별할 수 있어야 합니다.

이 관계는 데이터의 의미론적(Semantic) 특성에서 기인합니다. 예를 들어 `주민등록번호 → 이름`이라는 종속성은 주민등록번호가 시스템 내에서 고유하며 한 사람의 이름을 특정할 수 있다는 비즈니스 규칙에서 탄생합니다. 중요한 지점은, 이 관계가 현재 저장된 인스턴스에 의해 우연히 성립하는 것이 아니라, 스키마 설계 단계에서 영구히 보장되어야 하는 규칙이라는 점입니다. 결국 함수적 종속성을 파악하는 것은 데이터의 엔트로피를 통제하기 위해 '누가 누구를 지배하는가'를 규명하는 설계의 핵심 공정입니다.

![](/assets/img/2026-01-13-14-12-45.png)

### 함수적 종속의 유형별 판별

정규화의 단계를 결정짓는 것은 종속성의 '양상'입니다. 우리는 이를 세 가지 핵심 범주로 분류하여 데이터 구조의 결함을 진단합니다.

* **완전 함수 종속 (Full Functional Dependency)**: 종속자가 결정자의 '전체'에만 종속되는 경우입니다. 복합키가 결정자일 때, 특정 속성이 키의 일부가 아닌 전체 조합에 의해서만 결정된다면 이는 논리적으로 매우 견고한 상태입니다.
* **부분 함수 종속 (Partial Functional Dependency)**: 결정자가 복합키임에도 불구하고, 종속자가 키의 일부분에만 반응하는 현상입니다. 이는 불필요한 정보가 키의 곁다리에 붙어 중복을 야기하는 신호이며, 제2정규형(2NF)에서 도려내야 할 주된 타겟입니다.
* **이행적 함수 종속 (Transitive Functional Dependency)**: 직접적인 관계가 없는 속성들이 중간 매개체를 통해 연결된 상태입니다. $X \to Y$이고 $Y \to Z$여서 결과적으로 $X \to Z$가 성립한다면, $Z$는 $X$에 이행적으로 종속된 것입니다. 제3정규형(3NF)은 바로 이 징검다리 구조를 끊어내어 데이터 갱신 시의 연쇄 모순을 방지합니다.

### 암스트롱의 추론 규칙

현실의 데이터 모델은 수십 개의 속성이 얽혀 있어 종속성을 한눈에 파악하기 어렵습니다. 이때 엔지니어는 **암스트롱의 공리(Armstrong's Axioms)**라는 논리 도구를 사용하여 숨겨진 종속성을 찾아냅니다.

* **재귀성 규칙 (Reflexivity)**: $Y \subseteq X$이면, $X \to Y$이다. (자기 자신은 언제나 자신을 결정함)
* **부가성 규칙 (Augmentation)**: $X \to Y$이면, $XZ \to YZ$이다. (양변에 동일한 속성을 추가해도 종속성은 유지됨)
* **이행성 규칙 (Transitivity)**: $X \to Y$이고 $Y \to Z$이면, $X \to Z$이다.

이 세 가지 기본 규칙을 조합하면 '분해', '연합', '의사 이행' 등 파생 규칙을 만들어낼 수 있습니다. 이 과정은 마치 수학 문제를 풀듯 정교해야 하며, 이를 통해 도출된 **폐쇄 집합(Closure)**은 해당 릴레이션이 가질 수 있는 모든 후보키를 찾아내는 결정적 단서가 됩니다. 결국 함수적 종속성을 완벽히 이해한다는 것은, 데이터 간의 권력 구조를 파악하여 누가 '진정한 주인(Key)'인지를 가려내는 과정과 같습니다.

## 🧩 Normal Form

정규형(Normal Form)은 데이터베이스 설계가 도달해야 하는 일련의 무결성 지표입니다. 각 정규형은 이전 단계의 제약 조건을 모두 만족해야 하는 계층적 구조를 가집니다. 정규화 과정은 단순히 테이블을 쪼개는 행위가 아니라, 데이터 간의 함수적 종속성을 수학적으로 분석하여 '무손실 분해(Lossless Decomposition)'를 달성하는 고도의 공학적 최적화 과정입니다.

> **무손실 조인 분해**
> 
> 릴레이션 $R$을 $R_1$과 $R_2$로 분해했을 때, 이들을 다시 자연 조인(Natural Join)한 결과가 원래의 $R$과 완벽히 일치해야 합니다. 만약 분해 후 조인했을 때 존재하지 않던 가공의 튜플(Spurious Tuple)이 생성된다면, 그 분해는 잘못된 것입니다.
{: .prompt-tip }

### 원자값과 제1정규형

제1정규형(1NF)은 릴레이션이 되기 위한 가장 기초적인 자격 요건입니다. 모든 속성의 도메인이 원자값(Atomic Value)으로만 구성되어야 한다는 원칙입니다. 즉, 하나의 컬럼에 여러 개의 값을 넣거나(Multi-valued Attribute), 유사한 속성을 반복적으로 나열하는 구조(Repeating Group)를 허용하지 않습니다.

1NF를 위반하는 스키마는 쿼리의 복잡도를 비약적으로 상승시킵니다. 특정 속성 값의 일부만 검색하거나 수정하는 행위가 불가능해지며, 데이터의 집계와 분석 기능이 마비됩니다. 1NF의 달성은 데이터를 가장 작은 논리적 단위로 파편화하여, 향후 진행될 모든 정규화 단계의 기초 체력을 확보하는 작업입니다.

### 완전 함수 종속과 제2정규형

제2정규형(2NF)의 핵심 타겟은 '부분 함수 종속(Partial Functional Dependency)'입니다. 이 단계는 기본키가 두 개 이상의 속성으로 구성된 '복합키(Composite Key)'일 때 주로 문제가 됩니다. 

기본키의 일부분에만 종속된 속성이 존재한다면, 해당 속성은 기본키 전체와 관계를 맺는 것이 아니라 키의 일부에 기생하고 있는 꼴입니다. 2NF는 이러한 부분 종속 속성들을 별도의 릴레이션으로 분리할 것을 요구합니다. 이를 통해 기본키 전체에 대해서만 속성들이 결정되는 '완전 함수 종속' 상태를 만듭니다. 이 과정이 완료되면, 특정 엔티티의 부수적인 정보 때문에 기본 엔티티의 삽입이나 삭제가 제한되던 이상 현상이 획기적으로 줄어듭니다.

### 이행적 종속과 제3정규형

제3정규형(3NF)은 기본키가 아닌 속성들 사이의 종속 관계, 즉 '이행적 함수 종속(Transitive Functional Dependency)'을 제거합니다. $X \to Y$이고 $Y \to Z$일 때 $X \to Z$가 성립한다면, $Z$는 $X$에 이행적으로 종속된 것입니다.

실무적 관점에서 3NF는 "기본키가 아닌 속성은 오직 기본키에 의해서만 결정되어야 한다"는 원칙으로 요약됩니다. 예를 들어, '학번'이 '학과'를 결정하고 '학과'가 '강의실'을 결정한다면, 학번 릴레이션에 강의실 정보를 두어서는 안 됩니다. 학과와 강의실의 관계를 별도 테이블로 분리함으로써, 학과 정보가 수정될 때 수만 명의 학생 데이터를 일일이 업데이트해야 하는 갱신 이상의 위험을 원천 봉쇄합니다.

### 결정자 보완과 BCNF

Boyce-Codd 정규형(BCNF)은 3NF를 더욱 엄격하게 보완한 형태입니다. 3NF를 만족하더라도, 모든 결정자(Determinant)가 후보키(Candidate Key)가 아닌 경우가 발생할 수 있습니다. 특히 여러 개의 후보키가 중첩되어 존재하는 복잡한 릴레이션에서 이러한 허점이 드러납니다.

BCNF는 "모든 결정자는 반드시 후보키여야 한다"는 강력한 규칙을 세웁니다. 만약 후보키가 아닌 속성이 다른 속성을 결정하고 있다면, 그 결정 관계 역시 독립된 릴레이션으로 추출해야 합니다. BCNF까지 도달한 스키마는 함수적 종속성에 기인한 모든 이상 현상을 사실상 제거한 상태로 간주됩니다. 이는 데이터의 순수성을 극대화하여, 어떤 비즈니스 로직의 변화에도 데이터 모델이 논리적 모순에 빠지지 않도록 방어하는 최후의 보루입니다.

![](/assets/img/2026-01-13-14-17-53.png)

```sql
-- [Initial: 비정규화 상태]
-- Orders (OrderID, CustomerID, CustomerName, Items[ItemID, ItemName, Qty])
-- 문제: Items 속성이 원자적이지 않음 (다중값 속성)

-- [Step 1: 제1정규형 (1NF)]
-- 원칙: 모든 속성은 원자값을 가져야 함.
CREATE TABLE Order_1NF (
    OrderID INT,
    CustomerID INT,
    CustomerName VARCHAR(50),
    ItemID INT,
    ItemName VARCHAR(50),
    Quantity INT,
    PRIMARY KEY (OrderID, ItemID)
);

-- [Step 2: 제2정규형 (2NF)]
-- 원칙: 부분 함수 종속 제거 (기본키의 일부에만 종속된 속성 분리)
-- (OrderID, ItemID) -> Quantity (완전 종속)
-- OrderID -> CustomerID, CustomerName (부분 종속)
-- ItemID -> ItemName (부분 종속)

CREATE TABLE Order_Header ( -- 주문 기본 정보
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    CustomerName VARCHAR(50)
);

CREATE TABLE Item ( -- 아이템 마스터
    ItemID INT PRIMARY KEY,
    ItemName VARCHAR(50)
);

CREATE TABLE Order_Items ( -- 주문 상세 (완전 종속)
    OrderID INT,
    ItemID INT,
    Quantity INT,
    PRIMARY KEY (OrderID, ItemID),
    FOREIGN KEY (OrderID) REFERENCES Order_Header(OrderID),
    FOREIGN KEY (ItemID) REFERENCES Item(ItemID)
);

-- [Step 3: 제3정규형 (3NF)]
-- 원칙: 이행적 함수 종속 제거 (일반 속성 간의 종속 제거)
-- Order_Header에서 OrderID -> CustomerID 이고 CustomerID -> CustomerName 임.

CREATE TABLE Customer ( -- 고객 마스터로 분리
    CustomerID INT PRIMARY KEY,
    CustomerName VARCHAR(50)
);

ALTER TABLE Order_Header DROP COLUMN CustomerName; -- 중복 제거
ALTER TABLE Order_Header ADD FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID);

-- [Step 4: BCNF]
-- 원칙: 모든 결정자는 후보키여야 함.
-- 만약 (학번, 과목) -> 교수 이고 교수 -> 과목 인 관계가 있다면,
-- 결정자인 '교수'가 후보키가 아니므로 테이블을 분리함.

CREATE TABLE Professor_Subject (
    Professor VARCHAR(50) PRIMARY KEY,
    SubjectName VARCHAR(50)
);

CREATE TABLE Student_Course (
    StudentID INT,
    Professor VARCHAR(50),
    PRIMARY KEY (StudentID, Professor),
    FOREIGN KEY (Professor) REFERENCES Professor_Subject(Professor)
);
```

## Advanced Design

정규화의 여정은 BCNF에서 멈추지 않습니다. 비록 실무에서는 3NF나 BCNF 수준에서 설계를 타협하는 경우가 많지만, 데이터의 논리적 완결성을 추구하는 아키텍트라면 그 너머에 존재하는 고차 정규형과 실무적 트레이드오프의 경계를 이해해야 합니다. 이는 단순히 이론적인 유희가 아니라, 데이터 모델의 복잡성이 임계점을 넘었을 때 시스템을 보호하는 최후의 설계 전략입니다.

> **정규화의 역설**
> 
> 정규화는 중복을 제거하여 쓰기(Write) 성능과 무결성을 높이지만, 파편화된 테이블을 다시 합치는 조인(Join) 비용은 읽기(Read) 성능의 병목을 초래합니다. 완벽한 설계는 수학적 정교함과 물리적 성능 사이의 정교한 줄타기 결과물입니다.
{: .prompt-warning }

### 다치 종속과 제4정규형

제4정규형(4NF)은 '다치 종속(Multi-valued Dependency, MVD)'이라는 독특한 현상을 해결합니다. 릴레이션 내에 독립적인 두 개 이상의 다가 속성(Multi-valued Attribute)이 기본키에 종속될 때 발생합니다.

예를 들어, 한 명의 '교수'가 여러 '전공'을 가르치고 동시에 여러 '언어'를 구사한다고 가정해 봅시다. 전공과 언어는 서로 아무런 상관이 없음에도 불구하고, 하나의 릴레이션에 몰아넣으면 가능한 모든 조합이 튜플로 존재해야 하는 폭발적인 중복이 발생합니다. 4NF는 이러한 독립적인 다치 종속 관계를 별도의 릴레이션으로 분리할 것을 명령합니다. 이는 데이터의 의미적 독립성을 물리적 구조로 치환하는 작업입니다.

### 조인 종속과 무손실 분해

제5정규형(5NF)은 정규화의 이론적 정점인 '조인 종속(Join Dependency)'을 다룹니다. 어떤 릴레이션을 두 개로 분해했을 때는 정보 손실이 발생하지만, 세 개 이상의 릴레이션으로 분해했을 때 비로소 무손실 조인이 가능해지는 특수한 경우입니다.

실무에서 5NF까지 고려해야 하는 상황은 매우 드뭅니다. 하지만 순환 관계(Recursive Relationship)나 복잡한 다자간 관계(n-ary Relationship)를 설계할 때, 5NF의 원리를 이해하고 있다면 불필요한 조인 속성을 제거하여 스키마를 더욱 간결하게 유지할 수 있습니다. 이는 "데이터는 그 본연의 의미가 허용하는 최소 단위까지 쪼개져야 한다"는 원칙의 종착역입니다.

### 설계 최적화와 트레이드오프

모든 기술적 결정에는 비용이 따릅니다. 정규화가 깊어질수록 데이터의 정합성은 견고해지지만, 애플리케이션 개발자는 더 많은 `JOIN` 문과 싸워야 하며 데이터베이스 엔진은 CPU와 메모리를 소모하여 흩어진 데이터를 다시 모아야 합니다.

1. **전략적 반정규화(Denormalization)**: 읽기 빈도가 압도적으로 높고 실시간 성능이 지극히 중요한 경우, 의도적으로 중복을 허용합니다. 이는 설계를 포기하는 것이 아니라, 성능을 위해 정규화된 모델을 '계산된 방식'으로 붕괴시키는 고도의 최적화 기법입니다.
2. **무결성 비용의 이전**: 반정규화를 선택했다면, 데이터베이스가 보장해주던 무결성 검증의 책임을 애플리케이션 로직이나 배치 프로세스로 이전해야 합니다. 이 비용이 조인 비용보다 저렴한지 판단하는 것이 시니어 아키텍트의 역량입니다.

결국 훌륭한 스키마 설계란 정규형이라는 북극성을 따라가되, 현실의 인프라 제약이라는 중력을 무시하지 않는 균형 감각에서 탄생합니다.

## Summary

데이터베이스 정규화는 단순히 중복을 제거하는 기술적 절차를 넘어, 집합론과 함수적 종속성이라는 수학적 토대 위에 데이터의 무결성을 세우는 고도의 설계 철학입니다. 이상 현상을 방지하기 위해 릴레이션을 원자적 단위로 분해하는 과정은 시스템의 엔트로피를 낮추고, 데이터베이스를 신뢰할 수 있는 단일 진실 공급원(Single Source of Truth)으로 만듭니다. 비록 고차 정규화로 갈수록 조인 비용과 성능 사이의 트레이드오프가 발생하지만, 정규화된 모델을 기준점으로 삼아 전략적인 반정규화를 선택하는 것이 현대 아키텍트의 핵심 역량입니다. 결국 견고한 스키마 설계는 변화하는 비즈니스 요구사항 속에서도 데이터의 논리적 일관성을 유지할 수 있는 가장 강력한 방어 기제가 됩니다.

## References

* [[Wikipedia] Database normalization](https://en.wikipedia.org/wiki/Database_normalization)
* [[Redgate] Normalization in Relational Databases: 1NF, 2NF, and 3NF](https://www.red-gate.com/blog/normalization-1nf-2nf-3nf)
* [[GeeksforGeeks] Armstrong's Axioms in Functional Dependency](https://www.geeksforgeeks.org/armstrongs-axioms-in-functional-dependency-in-dbms/)
* [[CelerData] Normalization vs Denormalization: The Trade-offs](https://celerdata.com/glossary/normalization-vs-denormalization-the-trade-offs-you-need-to-know)