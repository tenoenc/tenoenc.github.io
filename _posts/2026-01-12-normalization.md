---
layout: post
title: "[DB Theory] Normalization"
date: 2026-01-12 14:30 +0900
math: true
categories:
- Computer Science
- Database Theory
tags:
- Database Theory
image:
    path: /assets/img/2026-01-12-15-57-10.png
---

엔지니어링의 세계에서 중복(Redundancy)은 양날의 검입니다. 읽기 성능을 위해 의도적으로 배치된 중복은 축복이지만, 설계의 부재로 인해 흘러 들어온 중복은 시스템의 엔트로피를 급격히 높이는 독소입니다. 정규화되지 않은 테이블은 시간이 흐를수록 거대하고 불투명한 덩어리가 되어갑니다. 하나의 행(Row)에 너무 많은 의미를 담으려는 욕심은 결국 **이상 현상(Anomaly)**이라는 대가를 치르게 합니다.

새로운 사용자를 추가하려는데 아직 구매한 상품이 없어서 삽입이 거부되거나(삽입 이상), 주소를 한 곳 수정했을 뿐인데 수천 개의 행에서 불일치가 발생하고(갱신 이상), 특정 이력을 지웠더니 그와 연동된 사용자 정보까지 영구히 소실되는(삭제 이상) 상황은 단순한 버그가 아닙니다. 이는 데이터 간의 논리적 결합도가 물리적 한계를 넘어섰음을 알리는 시스템의 비명입니다. 우리는 이 무질서한 실타래를 끊어내고, 데이터가 오직 '단 하나의 진실'만을 말하도록 강제해야 합니다. 이것이 우리가 정규화라는 고통스러운 분해 과정을 거쳐야 하는 근본적인 이유입니다.

## Relation

데이터베이스 이론에서 **릴레이션(Relation)**은 단순히 데이터를 담는 '표(Table)' 이상의 의미를 갖습니다. 이는 수학적 집합론에 뿌리를 둔 논리적 단위이며, 데이터 모델링의 원자(Atom)입니다. 릴레이션의 정체성은 그것을 구성하는 애트리뷰트(Attribute)들의 집합과, 그 집합이 규정하는 튜플(Tuple)들의 고유성에서 나옵니다.

### 수학적 집합으로서의 본질

릴레이션은 중복된 원소를 허용하지 않는 **집합(Set)**입니다. 따라서 물리적 테이블과 달리 릴레이션 내부의 튜플들은 순서에 의미가 없으며, 모든 튜플은 서로 식별 가능해야 합니다. 우리가 흔히 사용하는 '기본키(Primary Key)'는 이 집합론적 제약 조건을 물리적 환경에서 구현하기 위한 장치에 불과합니다. 릴레이션 내부의 모든 값은 더 이상 쪼개질 수 없는 **원자 값(Atomic Value)**이어야 한다는 1차 정규형(1NF)의 원칙은 사실 릴레이션 정의 그 자체에 내재된 속성입니다.

![](/assets/img/2026-01-12-15-25-58.png)

### 구조와 물리적 저장 방식의 불일치

논리적으로 릴레이션은 유연한 집합이지만, 디스크 위에 쓰여지는 순간 그것은 매우 딱딱한 물리적 구조를 갖게 됩니다. 데이터베이스 엔진은 릴레이션의 각 튜플을 페이지(Page)라는 단위로 묶어 저장합니다. 여기서 엔지니어링의 충돌이 발생합니다. 논리적으로 완벽하게 분해된 릴레이션은 데이터 무결성을 보장하지만, 실제 쿼리 시점에는 여러 페이지를 오가며 포인터를 추적해야 하는 오버헤드를 발생시킵니다. 

마틴 파울러(Martin Fowler)가 강조했듯, 데이터베이스 설계는 애플리케이션의 요구사항과 함께 진화해야 합니다. 릴레이션을 정의한다는 것은 단순히 칼럼을 나열하는 행위가 아니라, 데이터 간의 경계를 긋고 그 경계를 넘나드는 비용을 계산하는 아키텍처적 결정입니다. 각 애트리뷰트가 릴레이션 내에서 어떤 지위를 갖는지, 그리고 그들이 서로를 어떻게 결정짓는지 이해하는 것이 정규화의 다음 단계인 '함수적 종속성'으로 나아가는 유일한 길입니다.

> **데이터 무결성의 가치**
> 
> 시스템이 1ms 더 빨리 응답하는 것보다, 데이터가 오염되지 않았음을 확신하는 것이 엔지니어에게는 더 큰 평온을 줍니다. 릴레이션의 엄격한 구조는 그 평온을 지탱하는 최후의 보루입니다.
{: .prompt-info }

## Functional Dependency

정규화라는 공정이 데이터를 분해하는 '칼'이라면, **함수적 종속성(Functional Dependency, FD)**은 데이터들을 서로 붙들고 있는 '중력'과 같습니다. 어떤 애트리뷰트 $X$의 값을 알면 다른 애트리뷰트 $Y$의 값을 유일하게 결정할 수 있을 때, 우리는 "$Y$는 $X$에 함수적으로 종속된다"고 말하며 이를 $X \rightarrow Y$로 표기합니다.

이 단순해 보이는 화살표 하나가 데이터베이스의 모든 무결성 규칙을 지탱합니다. 만약 이 중력을 무시하고 데이터를 무분별하게 한 테이블에 몰아넣는다면, 시스템은 데이터 간의 논리적 모순이라는 블랙홀에 빠지게 됩니다.

### 결정자와 정보의 흐름

함수적 종속성에서 화살표의 왼쪽($X$)에 위치하는 요소를 **결정자**라고 부릅니다. 엔지니어링 관점에서 결정자는 특정 데이터 집합을 식별하기 위한 '최소한의 정보'입니다. 예를 들어, `학번 -> 이름`이라는 종속성이 있다면 '학번'은 '이름'이라는 정보를 찾아내기 위한 열쇠가 됩니다.

여기서 중요한 지점은 종속성의 **결정론적 성격**입니다. 동일한 결정자 값에 대해 항상 동일한 결과 값이 나와야 한다는 이 원칙은, 데이터베이스가 단순히 값을 저장하는 저장소를 넘어 논리적 일관성을 검증하는 연산 장치임을 시사합니다. 우리가 함수적 종속성을 파악하는 과정은, 사실 비즈니스 로직 속에 숨겨진 데이터의 인과관계를 코드로 박제하는 과정과 다름없습니다.

### 완전, 부분, 그리고 이행

정규화의 각 단계(Normal Forms)는 우리가 어떤 종류의 '나쁜 종속성'을 제거하느냐에 따라 정의됩니다. 이를 이해하기 위해서는 종속성의 세 가지 양상을 명확히 구분해야 합니다.

1.  **완전 함수적 종속(Full Functional Dependency)**: 기본키가 복합키($A, B$)일 때, 어떤 속성 $C$가 $A$와 $B$ 전체에 의해서만 결정되는 상태입니다. 이는 가장 이상적인 결합 상태입니다.
2.  **부분 함수적 종속(Partial Functional Dependency)**: 복합키($A, B$) 중 일부분인 $A$에 의해서만 $C$가 결정되는 경우입니다. 이는 테이블이 너무 많은 책임을 지고 있다는 신호이며, 2차 정규형(2NF)의 타격 대상이 됩니다.
3.  **이행적 함수적 종속(Transitive Functional Dependency)**: $A \rightarrow B$이고 $B \rightarrow C$일 때, 결과적으로 $A \rightarrow C$가 성립하는 관계입니다. $C$는 기본키 $A$에 직접 의존하는 것이 아니라 $B$를 거쳐서 의존하게 되며, 이는 3차 정규형(3NF)에서 분리되어야 할 대상입니다.

### 암스트롱의 추론 규칙

우리는 모든 종속성을 일일이 나열할 필요가 없습니다. **암스트롱의 추론 규칙(Armstrong's Axioms)**을 이용하면 기 존재하는 종속성으로부터 새로운 종속성을 논리적으로 유도할 수 있기 때문입니다. 반사 규칙, 첨가 규칙, 이행 규칙으로 구성된 이 체계는 데이터베이스 설계자가 복잡한 스키마 속에서도 데이터의 '최소 덮개(Minimal Cover)'를 찾을 수 있게 돕는 강력한 수학적 도구입니다.

```sql
/*
 * Armstrong's Axioms를 이용한 함수적 종속성 추론
 * 릴레이션 스키마 R(A, B, C, D, E)가 주어졌을 때
 */

-- 1. 주어진 종속성 (Given FDs)
-- FD1: {A, B} -> {C}  (A와 B의 조합이 C를 결정)
-- FD2: {C} -> {D, E}  (C가 D와 E를 결정)

-- 2. 추론 과정 (Inference)

-- [분해 규칙 / Decomposition]
-- FD2로부터 {C} -> {D}와 {C} -> {E}를 도출할 수 있음.

-- [이행 규칙 / Transitivity]
-- {A, B} -> {C} 이고 {C} -> {D} 이므로:
-- 결과: {A, B} -> {D} 가 성립함.

-- [결합 규칙 / Composition]
-- {A, B} -> {C} 이고 {A, B} -> {D} 이므로:
-- 결과: {A, B} -> {C, D} 가 성립함.

-- 3. 결론
-- {A, B}는 C, D, E를 모두 결정할 수 있는 결정자(Determinant)이며,
-- 만약 {A, B}가 최소성(Minimality)을 만족한다면 이 릴레이션의 후보키가 됨.
```

결국 함수적 종속성을 분석한다는 것은 데이터 사이의 불필요한 연결 고리를 끊어내고, 가장 순수한 형태의 관계만을 남기는 압축 과정입니다. 이 과정을 거쳐야만 비로소 우리는 데이터가 중복 없이, 가장 효율적인 형태로 저장될 준비가 되었다고 말할 수 있습니다.

> **결정자의 무게**
> 
> 잘못 선택된 결정자는 시스템 전체의 데이터 정합성을 무너뜨립니다. 함수적 종속성을 설계할 때는 현재의 데이터 분포뿐만 아니라, 미래에 변하지 않을 비즈니스의 불변 법칙(Invariant)을 반영해야 합니다.
{: .prompt-tip }

## Normalization

정규화는 데이터라는 원석을 깎아 순수한 결정체를 만드는 연금술과 같습니다. 우리는 앞서 살펴본 '함수적 종속성'이라는 도구를 손에 쥐고, 이제 본격적으로 테이블을 해체하기 시작합니다. 이 과정의 목표는 명확합니다. **"한 자리에는 하나의 값만, 그리고 모든 값은 오직 기본키에만 의존한다"**는 상태에 도달하는 것입니다.

정규화의 각 단계(Normal Forms)는 데이터가 겪을 수 있는 잠재적 결함을 걸러내는 필터 역할을 합니다. 우리는 이 필터를 하나씩 통과하며 데이터의 순도를 높여갑니다.

### 1NF: 원자성의 확보와 선형적 저장 구조

1차 정규형(1NF)은 릴레이션의 가장 기초적인 정의를 물리적으로 강제하는 단계입니다. 한 칸에 여러 개의 값이 들어있는 '다중 값 속성'을 허용하지 않습니다. 예를 들어, 한 명의 사용자가 여러 개의 전화번호를 쉼표로 구분해 들고 있다면, 이는 이미 릴레이션이 아닙니다.

엔지니어링 관점에서 1NF는 **저장소의 예측 가능성**을 의미합니다. 데이터베이스 엔진이 디스크에서 데이터를 읽어올 때, 각 칼럼의 크기가 가변적이고 구조가 복합적이라면 오프셋(Offset) 계산은 지옥으로 변합니다. 1NF를 준수함으로써 우리는 데이터 행의 구조를 정형화하고, 인덱스가 각 값을 정확히 가리킬 수 있는 토대를 마련합니다.

### 2NF: 부분 종속의 제거와 책임의 분리

2차 정규형(2NF)은 복합키(Composite Key) 환경에서 발생합니다. 기본키가 두 개 이상의 칼럼으로 구성되어 있을 때, 어떤 일반 속성이 키 전체가 아닌 '일부'에만 의존하고 있다면, 그 속성은 즉시 분리되어야 합니다.

이는 객체 지향 프로그래밍의 '단일 책임 원칙(SRP)'과 궤를 같이합니다. 하나의 테이블이 두 가지 서로 다른 실체(Entity)에 대한 정보를 동시에 들고 있을 때 부분 종속이 발생합니다. 2NF는 이러한 결합을 끊어내어, 각 테이블이 오직 하나의 주제에만 집중하도록 만듭니다.

### 3NF: 이행적 종속의 단절과 지름길 차단

3차 정규형(3NF)은 "기본키가 아닌 속성 간의 종속성"을 공격합니다. $A$가 키이고 $A \rightarrow B$, $B \rightarrow C$인 관계에서 $C$를 $A$ 테이블에 두는 것은 위험합니다. $B$ 값이 바뀌면 $C$도 바뀌어야 하는데, 이 정보가 여러 행에 흩어져 있다면 데이터 불일치는 피할 수 없는 운명이 됩니다.

3NF를 달성한다는 것은 데이터 간의 '중간 매개체'를 제거한다는 뜻입니다. 모든 속성이 기본키에 '직접' 매달리게 함으로써, 우리는 정보의 갱신 경로를 단일화합니다. 이것이 바로 우리가 추구하는 **단일 진실 공급원(Single Source of Truth)**의 핵심입니다.

![](/assets/img/2026-01-12-15-38-37.png)

### BCNF: 결정자의 권위 세우기

보이스-코드 정규형(BCNF)은 3NF보다 강력한 제약입니다. "모든 결정자는 후보키여야 한다"는 대원칙을 세웁니다. 여러 개의 후보키가 겹쳐 있는 특수한 상황에서도 데이터 이상 현상이 발생할 수 있는데, BCNF는 이를 원천 차단합니다. 

이 단계에 이르면 데이터 모델은 수학적으로 거의 완벽에 가까운 순수성을 얻습니다. 하지만 완벽에는 항상 대가가 따릅니다.

> **무손실 분해의 원칙 (Lossless Join)**
> 
> 테이블을 쪼갤 때 가장 중요한 것은 '다시 합칠 수 있는가'입니다. 잘못된 분해는 원래 존재하지 않던 가짜 데이터(Spurious Tuples)를 만들어냅니다. 정규화는 반드시 공통 속성을 매개로 하여 정보의 손실 없이 수행되어야 합니다.
{: .prompt-warning }

### 분해가 가저오는 물리적 파편화

정규화가 깊어질수록 데이터는 여러 테이블로 파편화됩니다. 논리적으로는 깔끔하지만, 하드웨어 계층에서는 비명이 터져 나옵니다. CPU는 메모리 곳곳에 흩어진 데이터를 모으기 위해 분주하게 움직여야 하며, 디스크 I/O는 여러 인덱스 트리를 오가며 탐색 비용을 지불합니다.

우리가 정규화를 '이론'으로만 배우지 않고 '엔지니어링'으로 다루어야 하는 이유가 여기 있습니다. 정규화는 목적지가 아니라 과정입니다. 시스템의 읽기/쓰기 비율, 쿼리의 복잡도, 그리고 하드웨어의 한계를 고려하지 않은 극단적인 정규화는 오히려 시스템의 가용성을 해치는 '교조적 설계'가 될 수 있습니다.

## JOIN의 물리적 비용과 하드웨어 마찰

정규화가 논리적 설계의 승리라면, **JOIN**은 그 승리를 쟁취하기 위해 지불해야 하는 가혹한 물리적 세금입니다. 테이블을 쪼갠다는 것은 데이터를 디스크와 메모리의 서로 다른 주소 공간으로 파편화시킨다는 뜻이며, 이를 다시 합치는 과정에서 데이터베이스 엔진은 하드웨어의 한계와 정면으로 충돌하게 됩니다.

### 논리의 분리와 물리적 파편화

우리가 `SELECT` 문에 `JOIN` 키워드를 적는 순간, 데이터베이스 엔진 내부에서는 거대한 물류 수송 작전이 시작됩니다. 정규화된 구조에서는 하나의 정보를 완성하기 위해 여러 테이블의 페이지(Page)를 읽어야 합니다. 이는 단순히 파일을 여러 번 여는 수준의 문제가 아닙니다.

물리적으로 데이터는 8KB 또는 16KB 단위의 페이지로 관리됩니다. 정규화가 심화될수록, 쿼리에 필요한 데이터들이 서로 다른 페이지, 심지어 서로 다른 익스텐트(Extent)에 흩어질 확률이 높아집니다. 엔진은 이 파편들을 모으기 위해 **랜덤 I/O(Random I/O)**를 발생시키며, 이는 순차 I/O에 비해 압도적으로 높은 지연 시간(Latency)을 초래합니다. 솔리드 스테이트 드라이브(SSD)의 시대라 할지라도, 커널 레벨에서의 컨텍스트 스위칭과 인터럽트 처리는 결코 공짜가 아닙니다.

### 인덱스 탐색과 CPU 캐시의 오버헤드

JOIN 연산의 핵심은 '연결 고리'를 찾는 과정입니다. 중첩 루프 조인(Nested Loop Join)을 예로 들면, 드라이빙 테이블의 각 행에 대해 드리븐 테이블의 인덱스를 반복적으로 탐색해야 합니다. 

이 과정에서 CPU는 바쁘게 움직이지만, 정작 효율은 떨어집니다. 인덱스 트리를 타고 내려가는 '포인터 추적(Pointer Chasing)' 작업은 **CPU 캐시 적중률(Cache Hit Rate)**을 급격히 떨어뜨리기 때문입니다. 데이터가 메모리에 올라와 있더라도(Buffer Pool Hit), CPU 캐시 라인에 담기지 못한 데이터는 메인 메모리(RAM)로부터의 인입을 기다려야 하며, 이 찰나의 기다림들이 모여 쿼리 응답 시간을 밀리초(ms) 단위로 끌어올립니다.

![](/assets/img/2026-01-12-15-37-22.png)

### 락 경합의 연쇄 반응

정규화는 데이터 일관성을 지켜주지만, 역설적으로 동시성 제어 측면에서는 병목을 만듭니다. 여러 테이블이 정교하게 연결되어 있을 때, 하나의 비즈니스 트랜잭션은 여러 테이블에 걸쳐 락(Lock)을 획득해야 합니다. 

정규화된 구조에서 특정 데이터를 수정하려면 연관된 여러 테이블의 인덱스와 행에 배타적 락을 걸어야 하며, 이는 다른 트랜잭션들이 줄을 서게 만드는 **락 경합**으로 이어집니다. 특히 트래픽이 몰리는 지점에서는 이 '정교한 분리'가 오히려 전체 시스템의 처리량(Throughput)을 갉아먹는 범인이 되기도 합니다.

> **엔지니어의 트레이드오프**
> 
> 정규화는 '저장소의 효율성'을 극대화하지만 '연산의 효율성'을 담보로 합니다. 현대 컴퓨팅에서 저장 공간은 저렴해졌고 CPU와 메모리 대역폭은 여전히 귀한 자원입니다. 따라서 우리는 정규화된 논리 모델이 하드웨어를 어떻게 괴롭히는지 실시간 모니터링을 통해 감시해야 합니다.
{: .prompt-warning }

## 언제 정규화를 멈추는가

엔지니어링은 완벽을 추구하는 학문이 아니라, 가용한 자원 속에서 최선의 타협점을 찾는 예술입니다. 데이터베이스 설계에서도 마찬가지입니다. 학부 과정에서 배우는 BCNF나 4NF, 5NF는 수학적으로는 아름답지만, 초당 수만 건의 요청이 쏟아지는 라이브 서비스 환경에서는 때로 '교조적 설계의 함정'이 되기도 합니다. 우리는 언제 정규화라는 칼을 내려놓고 **반정규화(Denormalization)**라는 전략적 후퇴를 선택해야 할까요?

### 읽기 부하와 복잡도

정규화를 멈춰야 하는 가장 강력한 신호는 **'조인(JOIN)의 깊이가 비즈니스 응답 시간을 초과할 때'**입니다. 데이터베이스는 애플리케이션의 요구사항에 따라 진화해야 합니다. 만약 특정 정보를 화면에 그리기 위해 7개 이상의 테이블을 조인해야 하고, 이 쿼리가 서비스의 메인 트래픽을 차지한다면 그것은 설계의 순수성을 포기하고 성능을 챙겨야 할 시점입니다.

반정규화는 결코 '실패한 설계'를 덮기 위한 임시방편이 아닙니다. 이는 데이터의 일관성을 유지하기 위한 비용(Write Side)과 사용자에게 빠른 경험을 제공하기 위한 이득(Read Side) 사이의 정밀한 계산 결과여야 합니다.

### 반정규화의 패턴

실무에서 흔히 사용되는 타협의 기술은 크게 세 가지로 나뉩니다.

* **칼럼의 중복 (Column Duplication)**: 조인 횟수를 줄이기 위해 자주 참조되는 속성(예: 사용자 이름)을 주문 테이블에 직접 저장합니다.
* **통계 테이블의 사전 계산 (Pre-computed Summary)**: 실시간 집계 연산의 부하를 막기 위해 일간 매출이나 포인트 합계 등을 별도 테이블로 관리합니다.
* **테이블 수직/수평 분할 (Partitioning)**: 정규화와는 별개로, 물리적 I/O를 분산시키기 위해 거대 테이블을 쪼개거나 합치는 결정을 내립니다.

```sql
/*
 * 전략적 반정규화: JOIN 비용 제거 및 일관성 관리
 * 시나리오: 초당 수만 건의 주문 목록 조회 시 사용자 이름(User Name) 노출 필요
 */

-- 1. 정규화된 상태의 비싼 JOIN 쿼리
-- SELECT o.id, o.amount, u.name 
-- FROM Orders o 
-- JOIN Users u ON o.user_id = u.id 
-- WHERE o.created_at > '2024-01-01';

-- 2. 반정규화 수행: Orders 테이블에 user_name 칼럼 중복 추가
ALTER TABLE Orders ADD COLUMN user_name VARCHAR(100);

-- 3. 데이터 일관성 보장을 위한 동기화 트리거 (MySQL 기준)
-- Users 테이블의 이름이 변경될 때 Orders의 중복 데이터도 함께 업데이트
DELIMITER //

CREATE TRIGGER trg_sync_user_name
AFTER UPDATE ON Users
FOR EACH ROW
BEGIN
    -- 이름이 실제로 변경된 경우에만 업데이트 수행 (쓰기 비용 최소화)
    IF OLD.name <> NEW.name THEN
        UPDATE Orders 
        SET user_name = NEW.name 
        WHERE user_id = NEW.id;
    END IF;
END; //

DELIMITER ;

-- 4. 최적화된 단일 테이블 조회 (JOIN 제거)
-- SELECT id, amount, user_name FROM Orders WHERE user_id = 12345;
```

### 일관성의 부채를 관리하는 법

반정규화를 선택하는 순간, 엔지니어는 **'데이터 불일치'**라는 부채를 짊어지게 됩니다. 원본 데이터가 수정되었을 때 중복된 데이터들을 어떻게 동기화할 것인가에 대한 답이 없다면, 반정규화는 시스템을 파괴하는 재앙이 됩니다.

고부하 환경에서는 DB의 물리적 한계를 극복하기 위해 캐시 계층을 도입하거나, 이벤트 기반의 비동기 업데이트를 통해 결과적 일관성(Eventual Consistency)을 확보하는 전략을 병행합니다. 즉, DB 설계의 타협은 반드시 애플리케이션 레벨에서의 보완책과 세트로 움직여야 합니다.

> "이 중복을 통해 우리가 얻는 성능 향상이, 향후 데이터 정합성을 맞추기 위해 지불할 유지보수 비용보다 압도적으로 큰가?" 

이 질문에 확신을 가지고 "YES"라고 답할 수 있을 때만, 정규화의 규칙을 깨뜨리십시오.

## Summary

데이터베이스 정규화는 단순히 중복을 제거하는 정리 정돈을 넘어, 시스템의 엔트로피를 제어하고 '단일 진실 공급원(SSOT)'을 사수하기 위한 엔지니어링의 정수입니다. 우리는 함수적 종속성이라는 논리적 도구를 통해 무질서한 데이터 사이의 인과관계를 규명하고, 이를 원자적 단위로 분해함으로써 데이터 이상 현상이라는 잠재적 재앙을 방지합니다. 하지만 정규화의 깊이가 깊어질수록 하드웨어는 JOIN 연산이라는 물리적 비용을 치러야 하며, 이는 곧 읽기 성능과 일관성 사이의 치열한 트레이드오프로 이어집니다. 결국 훌륭한 엔지니어는 이론적 완결성에 매몰되지 않고, 서비스의 트래픽 패턴과 하드웨어의 한계를 고려하여 정규화와 반정규화 사이의 최적의 균형점을 찾아내는 사람입니다.

## References

* [[Martin Fowler] Evolutionary Database Design](https://martinfowler.com/articles/evodb.html)
* [[DigitalOcean] Database Normalization (1NF to BCNF)](https://www.digitalocean.com/community/tutorials/database-normalization)
* [[SolarWinds] Normalize vs. Denormalize Database](https://www.solarwinds.com/database-optimization/normalize-vs-denormalize-database)
* [[Medium] Normalization in Action: Balancing Structure and Performance](https://medium.com/@renan.de.moraes777/normalization-in-action-balancing-structure-and-performance-in-data-modeling-36760ee933df)